<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_12) on Thu Apr 30 16:01:38 CDT 2009 -->
<TITLE>
Sentence (MorphAdorner)
</TITLE>

<META NAME="date" CONTENT="2009-04-30">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Sentence (MorphAdorner)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Resources.html" title="class in net.sf.jlinkgrammar"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../net/sf/jlinkgrammar/StartingLinkAndDomain.html" title="class in net.sf.jlinkgrammar"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/sf/jlinkgrammar/Sentence.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Sentence.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.sf.jlinkgrammar</FONT>
<BR>
Class Sentence</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>net.sf.jlinkgrammar.Sentence</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Sentence</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Routines for creating and destroying processing Sentences. It contains
  several its own copy of objects such as Dictionary, ParseInfo, Linkage, LinkageInfo,
  ParseOptions, and Postprocessor.  Much of the code still smacks of C rather than
  Java.  For instance  the critical ctable is not a collection object and ctable_length
  can be modified independently of the actual lenght of the table.
<p>
  There are other examples,  many routines take ParseOptions as an argument and yet use
  this.opts for their use.  If the programmer is not careful odd results may occur.
<p>
 One last note: Everything is reference via integer indexes into arrays rather than
 as objects. A natural object oriented approach would pass the Word  object and the
 routine would use Word.id to find the offset in the array.  This would improve type
 checking and overall program safety. - jlr
 <p>
 The most important
  routine is sentence_parse()
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_parse(net.sf.jlinkgrammar.ParseOptions)"><CODE>sentence_parse(ParseOptions)</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/AndData.html" title="class in net.sf.jlinkgrammar">AndData</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#and_data">and_data</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used to keep track of fat disjuncts</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#and_element">and_element</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#and_element_sizes">and_element_sizes</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#CMS_SIZE">CMS_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Cms.html" title="class in net.sf.jlinkgrammar">Cms</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#cms_table">cms_table</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html" title="class in net.sf.jlinkgrammar">TableConnector</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#ctable">ctable</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The TableConnector table associated with this sentence instance object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#ctable_size">ctable_size</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The size of this.ctable
 TODO - make this Java, not C, and use the collection object stuff!
 sp that ctable size can not be modified independently of ctable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#deletable">deletable</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deletable regions in a sentence with conjunction</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Dictionary.html" title="class in net.sf.jlinkgrammar">Dictionary</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#dict">dict</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;words are defined from this dictionary</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#effective_dist">effective_dist</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;created by build_effective_dist()</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#has_fat_down">has_fat_down</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/ImageNode.html" title="class in net.sf.jlinkgrammar">ImageNode</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#image_array">image_array</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/LinkageInfo.html" title="class in net.sf.jlinkgrammar">LinkageInfo</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#link_info">link_info</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array of valid and invalid linkages (sorted)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#match_cost">match_cost</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#match_l_table">match_l_table</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#match_l_table_size">match_l_table_size</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#match_r_table">match_r_table</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#match_r_table_size">match_r_table_size</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#N_and_elements">N_and_elements</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#N_changed">N_changed</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#N_outside_words">N_outside_words</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#null_count">null_count</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of null links in linkages</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#null_links">null_links</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#num_linkages_alloced">num_linkages_alloced</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total number of linkages allocated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#num_linkages_found">num_linkages_found</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total number linkages before postprocessing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#num_linkages_post_processed">num_linkages_post_processed</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of linkages that are actually
       put into the array that was alloced.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#num_valid_linkages">num_valid_linkages</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number with no pp violations</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#outside_word">outside_word</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/ParseInfo.html" title="class in net.sf.jlinkgrammar">ParseInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#parse_info">parse_info</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set of parses for the sentence</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/PatchElement.html" title="class in net.sf.jlinkgrammar">PatchElement</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#patch_array">patch_array</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#post_quote">post_quote</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#power_cost">power_cost</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/CList.html" title="class in net.sf.jlinkgrammar">CList</A>[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#power_l_table">power_l_table</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#power_l_table_size">power_l_table_size</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#power_prune_mode">power_prune_mode</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/CList.html" title="class in net.sf.jlinkgrammar">CList</A>[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#power_r_table">power_r_table</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#power_r_table_size">power_r_table_size</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#q_pruned_rules">q_pruned_rules</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;don't prune rules more than once in p.p.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#s_table_size">s_table_size</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#structure_violation">structure_violation</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#table">table</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#visited">visited</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../../../net/sf/jlinkgrammar/Word.html" title="class in net.sf.jlinkgrammar">Word</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#word">word</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array of words after tokenization</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#Sentence(java.lang.String, net.sf.jlinkgrammar.Dictionary, net.sf.jlinkgrammar.ParseOptions)">Sentence</A></B>(java.lang.String&nbsp;input_string,
         <A HREF="../../../net/sf/jlinkgrammar/Dictionary.html" title="class in net.sf.jlinkgrammar">Dictionary</A>&nbsp;dict,
         <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#add_one_connector(int, int, java.lang.String, net.sf.jlinkgrammar.Disjunct)">add_one_connector</A></B>(int&nbsp;label,
                  int&nbsp;dir,
                  java.lang.String&nbsp;cs,
                  <A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This adds one connector onto the beginning of the left (or right)
           connector list of d.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#add_to_left_table_list(net.sf.jlinkgrammar.MatchNode, net.sf.jlinkgrammar.MatchNode)">add_to_left_table_list</A></B>(<A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>&nbsp;m,
                       <A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the match node m to the sorted list of match nodes l.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#add_to_right_table_list(net.sf.jlinkgrammar.MatchNode, net.sf.jlinkgrammar.MatchNode)">add_to_right_table_list</A></B>(<A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>&nbsp;m,
                        <A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the match node m to the sorted list of match nodes l.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/LinkageInfo.html" title="class in net.sf.jlinkgrammar">LinkageInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#analyze_fat_linkage(net.sf.jlinkgrammar.ParseOptions, int)">analyze_fat_linkage</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                    int&nbsp;analyze_pass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This uses link_array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/LinkageInfo.html" title="class in net.sf.jlinkgrammar">LinkageInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#analyze_thin_linkage(net.sf.jlinkgrammar.ParseOptions, int)">analyze_thin_linkage</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                     int&nbsp;analyze_pass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This uses link_array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_AND_disjunct_list(java.lang.String)">build_AND_disjunct_list</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Builds and returns a disjunct list for "and", "or" and "nor"
 for each disjunct in the label_table, we build three disjuncts
 this means that "Danny and Tycho and Billy" will be parsable in
 two ways.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/AndList.html" title="class in net.sf.jlinkgrammar">AndList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_andlist()">build_andlist</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function computes the "and cost", resulting from inequalities in the word.size() of
           and-list elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_COMMA_disjunct_list()">build_COMMA_disjunct_list</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_conjunction_tables()">build_conjunction_tables</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_deletable(boolean)">build_deletable</A></B>(boolean&nbsp;has_conjunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initialize the array deletable[i][j] to indicate if the words
 i+1...j-1 could be non existant in one of the multiple linkages.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_disjuncts_for_XNode(net.sf.jlinkgrammar.ParseOptions, net.sf.jlinkgrammar.XNode, int)">build_disjuncts_for_XNode</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                          <A HREF="../../../net/sf/jlinkgrammar/XNode.html" title="class in net.sf.jlinkgrammar">XNode</A>&nbsp;x,
                          int&nbsp;cost_cutoff)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_effective_dist(boolean)">build_effective_dist</A></B>(boolean&nbsp;has_conjunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_fat_link_substitutions(net.sf.jlinkgrammar.Disjunct)">build_fat_link_substitutions</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_image_array()">build_image_array</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_parse_set(int, net.sf.jlinkgrammar.ParseOptions)">build_parse_set</A></B>(int&nbsp;cost,
                <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the top level call that computes the whole parse_set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_sentence_disjuncts(net.sf.jlinkgrammar.ParseOptions, int)">build_sentence_disjuncts</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                         int&nbsp;cost_cutoff)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We've already built the sentence expressions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_sentence_expressions(net.sf.jlinkgrammar.ParseOptions)">build_sentence_expressions</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Corrects case of first word, fills in other proper nouns, and
 builds the expression lists for the resulting words.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#clean_table(int, net.sf.jlinkgrammar.CList[])">clean_table</A></B>(int&nbsp;size,
            <A HREF="../../../net/sf/jlinkgrammar/CList.html" title="class in net.sf.jlinkgrammar">CList</A>[]&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This runs through all the connectors in this table, and eliminates those
           who are obsolete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#clean_up_expressions(int)">clean_up_expressions</A></B>(int&nbsp;w)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This removes the expressions that are empty from the list corresponding
  to word w of the sentence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#clean_up(int)">clean_up</A></B>(int&nbsp;w)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step three of the sentence_parse operation - pruning</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#cms_hash(java.lang.String)">cms_hash</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#compute_link_names()">compute_link_names</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#compute_matchers_for_a_label(int)">compute_matchers_for_a_label</A></B>(int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#compute_pp_link_array_connectors(net.sf.jlinkgrammar.Sublinkage)">compute_pp_link_array_connectors</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Sublinkage.html" title="class in net.sf.jlinkgrammar">Sublinkage</A>&nbsp;sublinkage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This takes as input link_array[], sublinkage.link[].l and
           sublinkage.link[].r (and also has_fat_down[word], which has been
           computed in a prior call to is_canonical()), and from these
           computes sublinkage.link[].lc and .rc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#compute_pp_link_names(net.sf.jlinkgrammar.Sublinkage)">compute_pp_link_names</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Sublinkage.html" title="class in net.sf.jlinkgrammar">Sublinkage</A>&nbsp;sublinkage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This fills in the sublinkage.link[].name field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#conj_in_range(int, int)">conj_in_range</A></B>(int&nbsp;lw,
              int&nbsp;rw)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determin if there is a conjunction between the suppled right and
 left words.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#conjunction_prune(net.sf.jlinkgrammar.ParseOptions)">conjunction_prune</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We've already built the sentence disjuncts, and we've pruned them
           and power_pruned(GENTLE) them also.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#connector_for_disjunct(net.sf.jlinkgrammar.Disjunct, net.sf.jlinkgrammar.Connector)">connector_for_disjunct</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d,
                       <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/DTypeList.html" title="class in net.sf.jlinkgrammar">DTypeList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#copy_d_type(net.sf.jlinkgrammar.DTypeList)">copy_d_type</A></B>(<A HREF="../../../net/sf/jlinkgrammar/DTypeList.html" title="class in net.sf.jlinkgrammar">DTypeList</A>&nbsp;dtl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy the named Domain Type List and return a copy</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#count_disjuncts_in_sentence()">count_disjuncts_in_sentence</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#count(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int, net.sf.jlinkgrammar.ParseOptions)">count</A></B>(int&nbsp;lw,
      int&nbsp;rw,
      <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
      <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
      int&nbsp;cost,
      <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#delete_from_cms_table(java.lang.String)">delete_from_cms_table</A></B>(java.lang.String&nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#delete_unmarked_disjuncts()">delete_unmarked_disjuncts</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#explode_disjunct_list(net.sf.jlinkgrammar.Disjunct)">explode_disjunct_list</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#expression_prune(net.sf.jlinkgrammar.ParseOptions)">expression_prune</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#extract_all_fat_links(net.sf.jlinkgrammar.Disjunct)">extract_all_fat_links</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#fast_match_hash(net.sf.jlinkgrammar.Connector)">fast_match_hash</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This hash function only looks at the leading upper case letters of
           the connector string, and the label fields.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#fill_patch_array_CON(net.sf.jlinkgrammar.CONNode, net.sf.jlinkgrammar.LinksToPatch)">fill_patch_array_CON</A></B>(<A HREF="../../../net/sf/jlinkgrammar/CONNode.html" title="class in net.sf.jlinkgrammar">CONNode</A>&nbsp;cn,
                     <A HREF="../../../net/sf/jlinkgrammar/LinksToPatch.html" title="class in net.sf.jlinkgrammar">LinksToPatch</A>&nbsp;ltp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#fill_patch_array_DIS(net.sf.jlinkgrammar.DISNode, net.sf.jlinkgrammar.LinksToPatch)">fill_patch_array_DIS</A></B>(<A HREF="../../../net/sf/jlinkgrammar/DISNode.html" title="class in net.sf.jlinkgrammar">DISNode</A>&nbsp;dn,
                     <A HREF="../../../net/sf/jlinkgrammar/LinksToPatch.html" title="class in net.sf.jlinkgrammar">LinksToPatch</A>&nbsp;ltp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Patches up appropriate links in the patch_array for this DISNode
 and this patch list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#find_subdisjunct(net.sf.jlinkgrammar.Disjunct, int)">find_subdisjunct</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;dis,
                 int&nbsp;label)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find the specific disjunct of in label_table[label]
           which corresponds to dis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#form_match_list(int, net.sf.jlinkgrammar.Connector, int, net.sf.jlinkgrammar.Connector, int)">form_match_list</A></B>(int&nbsp;w,
                <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;lc,
                int&nbsp;lw,
                <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;rc,
                int&nbsp;rw)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forms and returns a list of disjuncts that might match lc or rc or both.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#free_AND_tables()">free_AND_tables</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#free_HT()">free_HT</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#free_LT()">free_LT</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#free_parse_set()">free_parse_set</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#free_S()">free_S</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#free_sentence_disjuncts()">free_sentence_disjuncts</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#get_match_node()">get_match_node</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#glom_aux_connector(net.sf.jlinkgrammar.Disjunct, int, boolean)">glom_aux_connector</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d,
                   int&nbsp;label,
                   boolean&nbsp;necessary)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In this case the connector is to connect to the "either", "neither",
           "not", or some auxilliary d to the current which is a conjunction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#glom_comma_connector(net.sf.jlinkgrammar.Disjunct)">glom_comma_connector</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This file contains the functions for massaging disjuncts of the
   sentence in special ways having to do with conjunctions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#grow_LT()">grow_LT</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#hash_S(net.sf.jlinkgrammar.Connector)">hash_S</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This hash function only looks at the leading upper case letters of
           the connector string, and the label fields.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#hash(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int)">hash</A></B>(int&nbsp;lw,
     int&nbsp;rw,
     <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
     <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
     int&nbsp;cost)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#init_cms_table()">init_cms_table</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#init_fast_matcher()">init_fast_matcher</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#init_HT()">init_HT</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#init_LT()">init_LT</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#init_power()">init_power</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allocates and builds the initial power hash tables</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#init_table()">init_table</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A piecewise exponential function determines the size of the hash table.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#init_x_table()">init_x_table</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A piecewise exponential function determines the size of the hash table.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#initialize_conjunction_tables()">initialize_conjunction_tables</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#insert_in_cms_table(java.lang.String)">insert_in_cms_table</A></B>(java.lang.String&nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#insert_S(net.sf.jlinkgrammar.Connector)">insert_S</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#install_fat_connectors()">install_fat_connectors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#install_special_conjunctive_connectors()">install_special_conjunctive_connectors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#intersect_strings(java.lang.String, java.lang.String)">intersect_strings</A></B>(java.lang.String&nbsp;s,
                  java.lang.String&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#is_appropriate(net.sf.jlinkgrammar.Disjunct)">is_appropriate</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returns true if the disjunct is appropriate to be made into fat links.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#is_canonical_linkage()">is_canonical_linkage</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uses link_array[], chosen_disjuncts[], has_fat_down[].</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#left_connector_count(net.sf.jlinkgrammar.Disjunct)">left_connector_count</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returns the number of connectors in the left lists of the disjuncts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#left_connector_list_update(net.sf.jlinkgrammar.Connector, int, int, boolean)">left_connector_list_update</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                           int&nbsp;word_c,
                           int&nbsp;w,
                           boolean&nbsp;shallow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;take this connector list, and try to match it with the words
           w-1, w-2, w-3...Returns the word to which the first connector of the
           list could possibly be matched.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#left_disjunct_list_length(net.sf.jlinkgrammar.Disjunct)">left_disjunct_list_length</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#left_table_search(int, net.sf.jlinkgrammar.Connector, boolean, int)">left_table_search</A></B>(int&nbsp;w,
                  <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                  boolean&nbsp;shallow,
                  int&nbsp;word_c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Cms.html" title="class in net.sf.jlinkgrammar">Cms</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#lookup_in_cms_table(java.lang.String)">lookup_in_cms_table</A></B>(java.lang.String&nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#mark_region(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector)">mark_region</A></B>(int&nbsp;lw,
            int&nbsp;rw,
            <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
            <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#match_in_cms_table(java.lang.String)">match_in_cms_table</A></B>(java.lang.String&nbsp;pp_match_name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#matches_S(net.sf.jlinkgrammar.Connector, int)">matches_S</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
          int&nbsp;dir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returns true if c can match anything in the set S
 because of the horrible kludge, prune match is assymetric, and
 direction is '-' if this is an l.r pass, and '+' if an r.l pass.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#parse(int, net.sf.jlinkgrammar.ParseOptions)">parse</A></B>(int&nbsp;cost,
      <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of null links the sentence can be parsed with the
           specified cost Assumes that the hash table this.ctable has already been
           initialized, and is freed later.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#possible_connection(net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, boolean, boolean, int, int)">possible_connection</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;lc,
                    <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;rc,
                    boolean&nbsp;lshallow,
                    boolean&nbsp;rshallow,
                    int&nbsp;lword,
                    int&nbsp;rword)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this takes two connectors (and whether these are shallow or not)
           (and the two words that these came from) and returns true if it is
           possible for these two to match based on local considerations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#post_process_linkages(net.sf.jlinkgrammar.ParseOptions)">post_process_linkages</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is another top level call.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#post_process_scan_linkage(net.sf.jlinkgrammar.Postprocessor, net.sf.jlinkgrammar.ParseOptions, net.sf.jlinkgrammar.Sublinkage)">post_process_scan_linkage</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar">Postprocessor</A>&nbsp;pp,
                          <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                          <A HREF="../../../net/sf/jlinkgrammar/Sublinkage.html" title="class in net.sf.jlinkgrammar">Sublinkage</A>&nbsp;sublinkage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;During a first pass (prior to actual post-processing of the linkages
           of a sentence), call this once for every generated linkage.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/PPNode.html" title="class in net.sf.jlinkgrammar">PPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#post_process(net.sf.jlinkgrammar.Postprocessor, net.sf.jlinkgrammar.ParseOptions, net.sf.jlinkgrammar.Sublinkage, boolean)">post_process</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar">Postprocessor</A>&nbsp;pp,
             <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
             <A HREF="../../../net/sf/jlinkgrammar/Sublinkage.html" title="class in net.sf.jlinkgrammar">Sublinkage</A>&nbsp;sublinkage,
             boolean&nbsp;cleanup)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Takes a sublinkage and returns:

       .</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#power_hash(net.sf.jlinkgrammar.Connector)">power_hash</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This hash function only looks at the leading upper case letters of
           the connector string, and the label fields.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#power_prune(int, net.sf.jlinkgrammar.ParseOptions)">power_prune</A></B>(int&nbsp;mode,
            <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Here is what you've been waiting for: POWER-PRUNE</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#pp_and_power_prune(int, net.sf.jlinkgrammar.ParseOptions)">pp_and_power_prune</A></B>(int&nbsp;mode,
                   <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#pp_prune(net.sf.jlinkgrammar.ParseOptions)">pp_prune</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#prepare_to_parse(net.sf.jlinkgrammar.ParseOptions)">prepare_to_parse</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumes that the sentence expression lists have been generated
 this does all the necessary pruning and building of and
 structures.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#print_AND_statistics(net.sf.jlinkgrammar.ParseOptions)">print_AND_statistics</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#print_disjunct_counts(net.sf.jlinkgrammar.ParseOptions)">print_disjunct_counts</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#print_expression_sizes(net.sf.jlinkgrammar.ParseOptions)">print_expression_sizes</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#print_parse_statistics(net.sf.jlinkgrammar.ParseOptions)">print_parse_statistics</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#prune_irrelevant_rules(net.sf.jlinkgrammar.ParseOptions, net.sf.jlinkgrammar.Postprocessor)">prune_irrelevant_rules</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                       <A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar">Postprocessor</A>&nbsp;pp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call this (a) after having called post_process_scan_linkage() on all
           generated linkages, but (b) before calling post_process() on any
           particular linkage.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#prune(net.sf.jlinkgrammar.ParseOptions)">prune</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#pseudocount(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int)">pseudocount</A></B>(int&nbsp;lw,
            int&nbsp;rw,
            <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
            <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
            int&nbsp;cost)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#put_disjunct_into_table(net.sf.jlinkgrammar.Disjunct)">put_disjunct_into_table</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#put_into_match_table(int, net.sf.jlinkgrammar.MatchNode[], net.sf.jlinkgrammar.Disjunct, net.sf.jlinkgrammar.Connector, int)">put_into_match_table</A></B>(int&nbsp;size,
                     <A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>[]&nbsp;t,
                     <A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d,
                     <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                     int&nbsp;dir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The disjunct d (whose left or right pointer points to c) is put
           into the appropriate hash table</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#put_into_power_table(int, net.sf.jlinkgrammar.CList[], net.sf.jlinkgrammar.Connector, boolean)">put_into_power_table</A></B>(int&nbsp;size,
                     <A HREF="../../../net/sf/jlinkgrammar/CList.html" title="class in net.sf.jlinkgrammar">CList</A>[]&nbsp;t,
                     <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                     boolean&nbsp;shal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The disjunct d (whose left or right pointer points to c) is put
           into the appropriate hash table</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#region_valid(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector)">region_valid</A></B>(int&nbsp;lw,
             int&nbsp;rw,
             <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
             <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONJUNCTION PRUNING.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#right_connector_count(net.sf.jlinkgrammar.Disjunct)">right_connector_count</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returns the number of connectors in the right lists of the disjuncts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#right_connector_list_update(net.sf.jlinkgrammar.Connector, int, int, boolean)">right_connector_list_update</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                            int&nbsp;word_c,
                            int&nbsp;w,
                            boolean&nbsp;shallow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;take this connector list, and try to match it with the words
           w+1, w+2, w+3...Returns the word to which the first connector of the
           list could possibly be matched.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#right_disjunct_list_length(net.sf.jlinkgrammar.Disjunct)">right_disjunct_list_length</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the number of disjuncts in the list that have non-null
           right connector lists</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#right_table_search(int, net.sf.jlinkgrammar.Connector, boolean, int)">right_table_search</A></B>(int&nbsp;w,
                   <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                   boolean&nbsp;shallow,
                   int&nbsp;word_c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#rule_satisfiable(net.sf.jlinkgrammar.PPLinkset)">rule_satisfiable</A></B>(<A HREF="../../../net/sf/jlinkgrammar/PPLinkset.html" title="class in net.sf.jlinkgrammar">PPLinkset</A>&nbsp;ls)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_contains_conjunction()">sentence_contains_conjunction</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We've already built the sentence expressions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_contains(java.lang.String)">sentence_contains</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_disjunct_cost(int)">sentence_disjunct_cost</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_get_word(int)">sentence_get_word</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_length()">sentence_length</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get sentence word.size() in words</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_null_count()">sentence_null_count</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_num_linkages_found()">sentence_num_linkages_found</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_num_linkages_post_processed()">sentence_num_linkages_post_processed</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_num_valid_linkages()">sentence_num_valid_linkages</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_num_violations(int)">sentence_num_violations</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_parse(net.sf.jlinkgrammar.ParseOptions)">sentence_parse</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step three in parsing a sentence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#separate_sentence(java.lang.String, net.sf.jlinkgrammar.ParseOptions)">separate_sentence</A></B>(java.lang.String&nbsp;s,
                  <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The string s has just been read in from standard input.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#set_dist_fields(net.sf.jlinkgrammar.Connector, int, int)">set_dist_fields</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                int&nbsp;w,
                int&nbsp;delta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#set_has_fat_down()">set_has_fat_down</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#set_is_conjunction()">set_is_conjunction</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How is the is_conjunction table initialized?
 TODO - Remove English dependancy
 Also what about "yet", "however", "then", "else", "whence", "thus", ...</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#size_of_sentence_expressions()">size_of_sentence_expressions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes and returns the number of connectors in all of the expressions
           of the sentence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#size()">size</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#special_disjunct(int, int, java.lang.String, java.lang.String)">special_disjunct</A></B>(int&nbsp;label,
                 int&nbsp;dir,
                 java.lang.String&nbsp;cs,
                 java.lang.String&nbsp;ds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Builds a new disjunct with one connector pointing in direction dir
           (which is '+' or '-').</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#stick_in_one_connector(java.lang.StringBuffer, net.sf.jlinkgrammar.Connector, int)">stick_in_one_connector</A></B>(java.lang.StringBuffer&nbsp;s,
                       <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                       int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#strictly_smaller_name(java.lang.String, java.lang.String)">strictly_smaller_name</A></B>(java.lang.String&nbsp;s,
                      java.lang.String&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#strictly_smaller(java.lang.String, java.lang.String)">strictly_smaller</A></B>(java.lang.String&nbsp;s,
                 java.lang.String&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#table_lookup(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int)">table_lookup</A></B>(int&nbsp;lw,
             int&nbsp;rw,
             <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
             <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
             int&nbsp;cost)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html" title="class in net.sf.jlinkgrammar">TableConnector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#table_pointer(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int)">table_pointer</A></B>(int&nbsp;lw,
              int&nbsp;rw,
              <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
              <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
              int&nbsp;cost)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html" title="class in net.sf.jlinkgrammar">TableConnector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#table_store(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int, int)">table_store</A></B>(int&nbsp;lw,
            int&nbsp;rw,
            <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
            <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
            int&nbsp;cost,
            int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stores the value in the table this.ctable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#table_update(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int, int)">table_update</A></B>(int&nbsp;lw,
             int&nbsp;rw,
             <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
             <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
             int&nbsp;cost,
             int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#zero_S()">zero_S</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="dict"><!-- --></A><H3>
dict</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/Dictionary.html" title="class in net.sf.jlinkgrammar">Dictionary</A> <B>dict</B></PRE>
<DL>
<DD>words are defined from this dictionary
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="word"><!-- --></A><H3>
word</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../../../net/sf/jlinkgrammar/Word.html" title="class in net.sf.jlinkgrammar">Word</A>&gt; <B>word</B></PRE>
<DL>
<DD>array of words after tokenization
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="deletable"><!-- --></A><H3>
deletable</H3>
<PRE>
public boolean[][] <B>deletable</B></PRE>
<DL>
<DD>deletable regions in a sentence with conjunction
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="effective_dist"><!-- --></A><H3>
effective_dist</H3>
<PRE>
public int[][] <B>effective_dist</B></PRE>
<DL>
<DD>created by build_effective_dist()
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#build_effective_dist(boolean)"><CODE>build_effective_dist(boolean)</CODE></A></DL>
</DL>
<HR>

<A NAME="num_linkages_found"><!-- --></A><H3>
num_linkages_found</H3>
<PRE>
public int <B>num_linkages_found</B></PRE>
<DL>
<DD>total number linkages before postprocessing.  This
       is returned by the count() function
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="num_linkages_alloced"><!-- --></A><H3>
num_linkages_alloced</H3>
<PRE>
public int <B>num_linkages_alloced</B></PRE>
<DL>
<DD>total number of linkages allocated.
       the number post-processed might be fewer
       because some are non-canonical
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="num_linkages_post_processed"><!-- --></A><H3>
num_linkages_post_processed</H3>
<PRE>
public int <B>num_linkages_post_processed</B></PRE>
<DL>
<DD>The number of linkages that are actually
       put into the array that was alloced.
       this is not the same as num alloced
       because some may be non-canonical.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="num_valid_linkages"><!-- --></A><H3>
num_valid_linkages</H3>
<PRE>
public int <B>num_valid_linkages</B></PRE>
<DL>
<DD>number with no pp violations
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="null_count"><!-- --></A><H3>
null_count</H3>
<PRE>
public int <B>null_count</B></PRE>
<DL>
<DD>number of null links in linkages
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="parse_info"><!-- --></A><H3>
parse_info</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/ParseInfo.html" title="class in net.sf.jlinkgrammar">ParseInfo</A> <B>parse_info</B></PRE>
<DL>
<DD>set of parses for the sentence
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="link_info"><!-- --></A><H3>
link_info</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/LinkageInfo.html" title="class in net.sf.jlinkgrammar">LinkageInfo</A>[] <B>link_info</B></PRE>
<DL>
<DD>array of valid and invalid linkages (sorted)
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="and_data"><!-- --></A><H3>
and_data</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/AndData.html" title="class in net.sf.jlinkgrammar">AndData</A> <B>and_data</B></PRE>
<DL>
<DD>used to keep track of fat disjuncts
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="q_pruned_rules"><!-- --></A><H3>
q_pruned_rules</H3>
<PRE>
public boolean <B>q_pruned_rules</B></PRE>
<DL>
<DD>don't prune rules more than once in p.p.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="post_quote"><!-- --></A><H3>
post_quote</H3>
<PRE>
public int[] <B>post_quote</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="patch_array"><!-- --></A><H3>
patch_array</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/PatchElement.html" title="class in net.sf.jlinkgrammar">PatchElement</A>[] <B>patch_array</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="null_links"><!-- --></A><H3>
null_links</H3>
<PRE>
public static boolean <B>null_links</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ctable_size"><!-- --></A><H3>
ctable_size</H3>
<PRE>
public static int <B>ctable_size</B></PRE>
<DL>
<DD>The size of this.ctable
 TODO - make this Java, not C, and use the collection object stuff!
 sp that ctable size can not be modified independently of ctable.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="ctable"><!-- --></A><H3>
ctable</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/TableConnector.html" title="class in net.sf.jlinkgrammar">TableConnector</A>[] <B>ctable</B></PRE>
<DL>
<DD>The TableConnector table associated with this sentence instance object
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="match_cost"><!-- --></A><H3>
match_cost</H3>
<PRE>
public static int <B>match_cost</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="match_l_table_size"><!-- --></A><H3>
match_l_table_size</H3>
<PRE>
public static int[] <B>match_l_table_size</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="match_r_table_size"><!-- --></A><H3>
match_r_table_size</H3>
<PRE>
public static int[] <B>match_r_table_size</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="match_l_table"><!-- --></A><H3>
match_l_table</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>[][] <B>match_l_table</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="match_r_table"><!-- --></A><H3>
match_r_table</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>[][] <B>match_r_table</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="structure_violation"><!-- --></A><H3>
structure_violation</H3>
<PRE>
public static boolean <B>structure_violation</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="visited"><!-- --></A><H3>
visited</H3>
<PRE>
public static boolean[] <B>visited</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="and_element_sizes"><!-- --></A><H3>
and_element_sizes</H3>
<PRE>
public static int[] <B>and_element_sizes</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="and_element"><!-- --></A><H3>
and_element</H3>
<PRE>
public static int[] <B>and_element</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="N_and_elements"><!-- --></A><H3>
N_and_elements</H3>
<PRE>
public static int <B>N_and_elements</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="outside_word"><!-- --></A><H3>
outside_word</H3>
<PRE>
public static int[] <B>outside_word</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="N_outside_words"><!-- --></A><H3>
N_outside_words</H3>
<PRE>
public static int <B>N_outside_words</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="has_fat_down"><!-- --></A><H3>
has_fat_down</H3>
<PRE>
public static boolean[] <B>has_fat_down</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="image_array"><!-- --></A><H3>
image_array</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/ImageNode.html" title="class in net.sf.jlinkgrammar">ImageNode</A>[] <B>image_array</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="s_table_size"><!-- --></A><H3>
s_table_size</H3>
<PRE>
public static int <B>s_table_size</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="table"><!-- --></A><H3>
table</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>[] <B>table</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="power_cost"><!-- --></A><H3>
power_cost</H3>
<PRE>
public static int <B>power_cost</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="power_prune_mode"><!-- --></A><H3>
power_prune_mode</H3>
<PRE>
public static int <B>power_prune_mode</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="N_changed"><!-- --></A><H3>
N_changed</H3>
<PRE>
public static int <B>N_changed</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="power_l_table_size"><!-- --></A><H3>
power_l_table_size</H3>
<PRE>
public static int[] <B>power_l_table_size</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="power_r_table_size"><!-- --></A><H3>
power_r_table_size</H3>
<PRE>
public static int[] <B>power_r_table_size</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="power_l_table"><!-- --></A><H3>
power_l_table</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/CList.html" title="class in net.sf.jlinkgrammar">CList</A>[][] <B>power_l_table</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="power_r_table"><!-- --></A><H3>
power_r_table</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/CList.html" title="class in net.sf.jlinkgrammar">CList</A>[][] <B>power_r_table</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="CMS_SIZE"><!-- --></A><H3>
CMS_SIZE</H3>
<PRE>
public static final int <B>CMS_SIZE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#net.sf.jlinkgrammar.Sentence.CMS_SIZE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cms_table"><!-- --></A><H3>
cms_table</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/Cms.html" title="class in net.sf.jlinkgrammar">Cms</A>[] <B>cms_table</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Sentence(java.lang.String, net.sf.jlinkgrammar.Dictionary, net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
Sentence</H3>
<PRE>
public <B>Sentence</B>(java.lang.String&nbsp;input_string,
                <A HREF="../../../net/sf/jlinkgrammar/Dictionary.html" title="class in net.sf.jlinkgrammar">Dictionary</A>&nbsp;dict,
                <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="separate_sentence(java.lang.String, net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
separate_sentence</H3>
<PRE>
public boolean <B>separate_sentence</B>(java.lang.String&nbsp;s,
                                 <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD>The string s has just been read in from standard input.
 This function breaks it up into words and stores these words in
 the sent.word[] array.
 Quote marks are treated just like blanks.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - sentence in String form<DD><CODE>opts</CODE> - passes ParseOptions - In reality these are often kept in global variables. TODO - clean up code
<DT><B>Returns:</B><DD>Returns true if all is well, false otherwise.<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar"><CODE>ParseOptions</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="build_sentence_expressions(net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
build_sentence_expressions</H3>
<PRE>
public void <B>build_sentence_expressions</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD>Corrects case of first word, fills in other proper nouns, and
 builds the expression lists for the resulting words.
 <p>
 Algorithm:
 <ul>
 <li>          Apply the following step to all words w:
 <li>          if w is in the dictionary, use it.
 <li>          else if w is upper case use PROPER_WORD disjuncts for w.
 <li>          else if it's hyphenated, use HYPHENATED_WORD
 <li>          else if it's a number, use NUMBER_WORD.
 <li>
 <li>          Now, we correct the first word, w.
 <li>          if w is upper case, let w' be the lower case version of w.
 <li>          if both w and w' are in the dict, concatenate these disjuncts.
 <li>          else if w' is in dict, use disjuncts of w'
 <li>          else leave the disjuncts alone
 </us>
<p>
 Here's a summary of how subscripts are handled:
 <p>
  Reading the dictionary:
 <p>
    If the last "." in a string is followed by a non-digit character,
    then the "." and everything after it is considered to be the subscript
    of the word.
 <p>
    The dictionary reader does not allow you to have two words that
    match according to the criterion below.  (so you can't have
    "dog.n" and "dog")
 <p>
    Quote marks are used to allow you to define words in the dictionary
    which would otherwise be considered part of the dictionary, as in
 <p>
     ";": {&#064Xca-} & Xx- & (W+ or Qd+) & {Xx+};
     "%" : (ND- & {DD-} & \<noun-sub-x\> &
     (\<noun-main-x\> or B*x+)) or (ND- & (OD- or AN+));
 <p>
  Rules for chopping words from the input sentence:
 <p>
     First the prefix chars are stripped off of the word.  These
     characters are "(" and "$" (and now "``")
 <p>
     Now, repeat the following as long as necessary:
 <p>
     Look up the word in the dictionary.
     If it's there, the process terminates.
 <p>
     If it's not there and it ends in one of the right strippable
     strings (see "right_strip") then remove the strippable string
     and make it into a separate word.
 <p>
     If there is no strippable string, then the process terminates.
 <p>
  Rule for defining subscripts in input words:
 <p>
     The subscript rule is followed just as when reading the dictionary.
 <p>
  When does a word in the sentence match a word in the dictionary?
 <p>
     Matching is done as follows: Two words with subscripts must match
     exactly.  If neither has a subscript they must match exactly.  If one
     does and one doesn't then they must match when the subscript is
     removed.  Notice that this is symmetric.
 <p>
  So, under this system, the dictonary could have the words "Ill" and
  also the word "Ill."  It could also have the word "i.e.", which could be
  used in a sentence.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - - not used everything comes from GlobalBean. TODO - Fix or drop</DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A><H3>
size</H3>
<PRE>
public int <B>size</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="initialize_conjunction_tables()"><!-- --></A><H3>
initialize_conjunction_tables</H3>
<PRE>
public void <B>initialize_conjunction_tables</B>()</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/AndData.html" title="class in net.sf.jlinkgrammar"><CODE>AndData</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="set_is_conjunction()"><!-- --></A><H3>
set_is_conjunction</H3>
<PRE>
public void <B>set_is_conjunction</B>()</PRE>
<DL>
<DD>How is the is_conjunction table initialized?
 TODO - Remove English dependancy
 Also what about "yet", "however", "then", "else", "whence", "thus", ...
 Word word.get(w) has a list of equivilent expressions that should be followed
 what is needed here is:

 if (isConjunct(word.get(w))||isDisjunct(word.get(w))||isAdjunct(word.get(w))) then is_conjunction[w] = true;

 where isConjunct(Word word) walks down the list of equivilent expressions
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sentence_length()"><!-- --></A><H3>
sentence_length</H3>
<PRE>
public int <B>sentence_length</B>()</PRE>
<DL>
<DD>get sentence word.size() in words
<P>
<DD><DL>

<DT><B>Returns:</B><DD>int word.size()</DL>
</DD>
</DL>
<HR>

<A NAME="prepare_to_parse(net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
prepare_to_parse</H3>
<PRE>
public void <B>prepare_to_parse</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD>assumes that the sentence expression lists have been generated
 this does all the necessary pruning and building of and
 structures.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - parsing options</DL>
</DD>
</DL>
<HR>

<A NAME="conjunction_prune(net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
conjunction_prune</H3>
<PRE>
public void <B>conjunction_prune</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD>We've already built the sentence disjuncts, and we've pruned them
           and power_pruned(GENTLE) them also.  The sentence contains a
           conjunction.  deletable[][] has been initialized to indicate the
           ranges which may be deleted in the final linkage.

           This routine deletes irrelevant disjuncts.  It finds them by first
           marking them all as irrelevant, and then marking the ones that
           might be useable.  Finally, the unmarked ones are removed.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - parsing options used to set tolerance for nulls</DL>
</DD>
</DL>
<HR>

<A NAME="region_valid(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector)"><!-- --></A><H3>
region_valid</H3>
<PRE>
public int <B>region_valid</B>(int&nbsp;lw,
                        int&nbsp;rw,
                        <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
                        <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re)</PRE>
<DL>
<DD>CONJUNCTION PRUNING.

    The basic idea is this.  Before creating the fat disjuncts,
    we run a modified version of the exhaustive search procedure.
    Its purpose is to mark the disjuncts that can be used in any
    linkage.  It's just like the normal exhaustive search, except that
    if a subrange of words are deletable, then we treat them as though
    they were not even there.  So, if we call the function in the
    situation where the set of words between the left and right one
    are deletable, and the left and right connector pointers
    are null, then that range is considered to have a solution.

    There are actually two procedures to implement this.  One is
    mark_region() and the other is region_valid().  The latter just
    checks to see if the given region can be completed (within it).
    The former actually marks those disjuncts that can be used in
    any valid linkage of the given region.

    As in the standard search procedure, we make use of the fast-match
    data structure (which requires power pruning to have been done), and
    we also use a hash table.  The table is used differently in this case.
    The meaning of values stored in the table are as follows:

    -1  Nothing known (Actually, this is not stored.  It's returned
    by table_lookup when nothing is known.)
    0  This region can't be completed (marking is therefore irrelevant)
    1  This region can be completed, but it's not yet marked
    2  This region can be completed, and it's been marked.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lw</CODE> - integer word number of left wall<DD><CODE>rw</CODE> - integer word number of right wall<DD><CODE>le</CODE> - left expression<DD><CODE>re</CODE> - right expression
<DT><B>Returns:</B><DD>Returns 0 if this range cannot be successfully filled in with links.
 Returns 1 if it can, and it's not been marked, and
 Returns 2 if it can and it has been marked.</DL>
</DD>
</DL>
<HR>

<A NAME="form_match_list(int, net.sf.jlinkgrammar.Connector, int, net.sf.jlinkgrammar.Connector, int)"><!-- --></A><H3>
form_match_list</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A> <B>form_match_list</B>(int&nbsp;w,
                                        <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;lc,
                                        int&nbsp;lw,
                                        <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;rc,
                                        int&nbsp;rw)</PRE>
<DL>
<DD>Forms and returns a list of disjuncts that might match lc or rc or both.
 lw and rw are the words from which lc and rc came respectively.
 The list is formed by the link pointers of MatchNodes.
 The list contains no duplicates.  A quadratic algorithm is used to
 eliminate duplicates.  In practice the match_cost is less than the
 parse_cost (and the loop is tiny), so there's no reason to bother
 to fix this.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w</CODE> - array index of word to match<DD><CODE>lc</CODE> - left Connector<DD><CODE>lw</CODE> - index into word array of left word<DD><CODE>rc</CODE> - right Connector<DD><CODE>rw</CODE> - index into word array of right word
<DT><B>Returns:</B><DD>the right match</DL>
</DD>
</DL>
<HR>

<A NAME="get_match_node()"><!-- --></A><H3>
get_match_node</H3>
<PRE>
static <A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A> <B>get_match_node</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="table_update(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int, int)"><!-- --></A><H3>
table_update</H3>
<PRE>
void <B>table_update</B>(int&nbsp;lw,
                  int&nbsp;rw,
                  <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
                  <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
                  int&nbsp;cost,
                  int&nbsp;count)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="mark_region(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector)"><!-- --></A><H3>
mark_region</H3>
<PRE>
void <B>mark_region</B>(int&nbsp;lw,
                 int&nbsp;rw,
                 <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
                 <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="explode_disjunct_list(net.sf.jlinkgrammar.Disjunct)"><!-- --></A><H3>
explode_disjunct_list</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A> <B>explode_disjunct_list</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="build_COMMA_disjunct_list()"><!-- --></A><H3>
build_COMMA_disjunct_list</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A> <B>build_COMMA_disjunct_list</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="install_fat_connectors()"><!-- --></A><H3>
install_fat_connectors</H3>
<PRE>
void <B>install_fat_connectors</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="build_fat_link_substitutions(net.sf.jlinkgrammar.Disjunct)"><!-- --></A><H3>
build_fat_link_substitutions</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A> <B>build_fat_link_substitutions</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="connector_for_disjunct(net.sf.jlinkgrammar.Disjunct, net.sf.jlinkgrammar.Connector)"><!-- --></A><H3>
connector_for_disjunct</H3>
<PRE>
public void <B>connector_for_disjunct</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d,
                                   <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>d</CODE> - <DD><CODE>c</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="build_AND_disjunct_list(java.lang.String)"><!-- --></A><H3>
build_AND_disjunct_list</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A> <B>build_AND_disjunct_list</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD>Builds and returns a disjunct list for "and", "or" and "nor"
 for each disjunct in the label_table, we build three disjuncts
 this means that "Danny and Tycho and Billy" will be parsable in
 two ways.  I don't know an easy way to avoid this
 the string is either "and", or "or", or "nor" at the moment
 <p>
 must accommodate "he and I are good", "Davy and I are good"
      "Danny and Davy are good", and reject all of these with "is"
      instead of "are".
 <p>
      The SI connectors must also be modified to accommodate "are John
      and Dave here", but kill "is John and Dave here"
 <p>
    Then we consider "a cat or a dog is here"  vs  "a cat or a dog are here"
     The first seems right, the second seems wrong.  I'll stick with this.

     That is, "or" has the property that if both parts are the same in
     number,  we use that but if they differ, we use plural.
 <p>
     The connectors on "I" must be handled specially.  We accept
     "I or the dogs are here" but reject "I or the dogs is here"
 <p>
 TODO - the code here still does now work "right", rejecting "is John or I invited"
      and accepting "I or my friend know what happened"

      The more generous code for "nor" has been used instead
 <p>
 It appears that the "nor" of two things can be either singular or
      plural.
 <p>
 "neither she nor John likes dogs"
<p>
 "neither she nor John like dogs"
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - 
<DT><B>Returns:</B><DD>head of a disjunct list<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar"><CODE>Connector</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="build_conjunction_tables()"><!-- --></A><H3>
build_conjunction_tables</H3>
<PRE>
public void <B>build_conjunction_tables</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="compute_matchers_for_a_label(int)"><!-- --></A><H3>
compute_matchers_for_a_label</H3>
<PRE>
public void <B>compute_matchers_for_a_label</B>(int&nbsp;k)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>k</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="stick_in_one_connector(java.lang.StringBuffer, net.sf.jlinkgrammar.Connector, int)"><!-- --></A><H3>
stick_in_one_connector</H3>
<PRE>
public void <B>stick_in_one_connector</B>(java.lang.StringBuffer&nbsp;s,
                                   <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                                   int&nbsp;len)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - <DD><CODE>c</CODE> - <DD><CODE>len</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="extract_all_fat_links(net.sf.jlinkgrammar.Disjunct)"><!-- --></A><H3>
extract_all_fat_links</H3>
<PRE>
public void <B>extract_all_fat_links</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>d</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="put_disjunct_into_table(net.sf.jlinkgrammar.Disjunct)"><!-- --></A><H3>
put_disjunct_into_table</H3>
<PRE>
public void <B>put_disjunct_into_table</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>d</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="grow_LT()"><!-- --></A><H3>
grow_LT</H3>
<PRE>
void <B>grow_LT</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="is_appropriate(net.sf.jlinkgrammar.Disjunct)"><!-- --></A><H3>
is_appropriate</H3>
<PRE>
public boolean <B>is_appropriate</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</PRE>
<DL>
<DD>returns true if the disjunct is appropriate to be made into fat links.
           Check here that the connectors are from some small set.
           This will disallow, for example "the and their dog ran".
<p>
 TODO: move to dict
<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>d</CODE> - 
<DT><B>Returns:</B><DD>true if the disjunct is appropriate to be made into fat links</DL>
</DD>
</DL>
<HR>

<A NAME="init_HT()"><!-- --></A><H3>
init_HT</H3>
<PRE>
public void <B>init_HT</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="init_LT()"><!-- --></A><H3>
init_LT</H3>
<PRE>
public void <B>init_LT</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="print_AND_statistics(net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
print_AND_statistics</H3>
<PRE>
public void <B>print_AND_statistics</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="build_effective_dist(boolean)"><!-- --></A><H3>
build_effective_dist</H3>
<PRE>
public void <B>build_effective_dist</B>(boolean&nbsp;has_conjunction)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>has_conjunction</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="build_deletable(boolean)"><!-- --></A><H3>
build_deletable</H3>
<PRE>
public void <B>build_deletable</B>(boolean&nbsp;has_conjunction)</PRE>
<DL>
<DD>Initialize the array deletable[i][j] to indicate if the words
 i+1...j-1 could be non existant in one of the multiple linkages.  This
 array is used in conjunction_prune and power_prune.  Regions of word.size()
 0 are always deletable.  A region of word.size() two with a conjunction at
 one end is always deletable.  Another observation is that for the
 comma to form the right end of a deletable region, it must be the case
 that there is a conjunction to the right of the comma.  Also, when
 considering deletable regions with a comma on their left sides, there
 must be a conjunction inside the region to be deleted. Finally, the
 words "either", "neither", "both", "not" and "not only" are all
 deletable.
<p>
 TODO - This is awfully ethnocentric. What about other languages, or words like
 thus, thence, whence etc.  This should be a loadable array!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>has_conjunction</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="conj_in_range(int, int)"><!-- --></A><H3>
conj_in_range</H3>
<PRE>
public boolean <B>conj_in_range</B>(int&nbsp;lw,
                             int&nbsp;rw)</PRE>
<DL>
<DD>Determin if there is a conjunction between the suppled right and
 left words.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lw</CODE> - integer index of left word<DD><CODE>rw</CODE> - integer index of right word
<DT><B>Returns:</B><DD>true if the range lw...rw inclusive contains a conjunction</DL>
</DD>
</DL>
<HR>

<A NAME="sentence_parse(net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
sentence_parse</H3>
<PRE>
public int <B>sentence_parse</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD>Step three in parsing a sentence. First you must create a dictionary, then a sentence, then call this
 method to generate a parse tree.  This is really the heart of the system.  There are several things
 done when a sentence is parsed.
<ul>
<li>  Word expressions are extracted from the dictionary and pruned
<li> Disjuncts are built
<li>  Aseries of pruning operations are carried out.
<li>  The linkages having the minimum number of null links are counted.
<li>  A "parse set" of linkages is built.
<li>  The linkages are post processed
</ul>
The "parse set" is attached to the sentence, and this is one of the key reasons that
the API is flexible and modular.  All of the necessary information for building linkages
is stored in the parse set.  This means that other sentences can be parsed, possibly using
different dictionaries, without disturbing the information obtained from a call to sentence_parse.
If another call to sentence_parse is made on the same sentence, the parsing information
for the previous call is deleted.
<p>
O.K. that may be true of the C code version but in this code a lot of information
from ParseOptions is held in GlobalBean.
<p>
 TODO - Make the dictionary and ParseInfo private
to the sentence.  Then add getter and setter methods.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - 
<DT><B>Returns:</B><DD>the number of valid linkages.<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#num_linkages_found"><CODE>num_linkages_found</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="parse(int, net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
parse</H3>
<PRE>
public int <B>parse</B>(int&nbsp;cost,
                 <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD>Returns the number of null links the sentence can be parsed with the
           specified cost Assumes that the hash table this.ctable has already been
           initialized, and is freed later.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cost</CODE> - <DD><CODE>opts</CODE> - 
<DT><B>Returns:</B><DD>the number of null links in this.ctable</DL>
</DD>
</DL>
<HR>

<A NAME="count(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int, net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
count</H3>
<PRE>
public int <B>count</B>(int&nbsp;lw,
                 int&nbsp;rw,
                 <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
                 <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
                 int&nbsp;cost,
                 <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lw</CODE> - <DD><CODE>rw</CODE> - <DD><CODE>le</CODE> - <DD><CODE>re</CODE> - <DD><CODE>cost</CODE> - <DD><CODE>opts</CODE> - 
<DT><B>Returns:</B><DD>the total number of links in a TableConnector this.ctable matching input parameters</DL>
</DD>
</DL>
<HR>

<A NAME="pseudocount(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int)"><!-- --></A><H3>
pseudocount</H3>
<PRE>
public int <B>pseudocount</B>(int&nbsp;lw,
                       int&nbsp;rw,
                       <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
                       <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
                       int&nbsp;cost)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lw</CODE> - <DD><CODE>rw</CODE> - <DD><CODE>le</CODE> - <DD><CODE>re</CODE> - <DD><CODE>cost</CODE> - 
<DT><B>Returns:</B><DD>0 if and only if this entry is in the hash table with a count value of 0</DL>
</DD>
</DL>
<HR>

<A NAME="init_x_table()"><!-- --></A><H3>
init_x_table</H3>
<PRE>
public void <B>init_x_table</B>()</PRE>
<DL>
<DD>A piecewise exponential function determines the size of the hash table.
 Probably should make use of the actual number of disjuncts, rather than just
 the number of words
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="init_table()"><!-- --></A><H3>
init_table</H3>
<PRE>
public void <B>init_table</B>()</PRE>
<DL>
<DD>A piecewise exponential function determines the size of the hash table.
 Probably should make use of the actual number of disjuncts, rather than just
 the number of words
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="table_lookup(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int)"><!-- --></A><H3>
table_lookup</H3>
<PRE>
public static int <B>table_lookup</B>(int&nbsp;lw,
                               int&nbsp;rw,
                               <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
                               <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
                               int&nbsp;cost)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lw</CODE> - <DD><CODE>rw</CODE> - <DD><CODE>le</CODE> - <DD><CODE>re</CODE> - <DD><CODE>cost</CODE> - 
<DT><B>Returns:</B><DD>the count for this quintuple if there, -1 otherwise<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#lw"><CODE>TableConnector.lw</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#rw"><CODE>TableConnector.rw</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#le"><CODE>TableConnector.le</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#re"><CODE>TableConnector.re</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#cost"><CODE>TableConnector.cost</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hash(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int)"><!-- --></A><H3>
hash</H3>
<PRE>
public static int <B>hash</B>(int&nbsp;lw,
                       int&nbsp;rw,
                       <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
                       <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
                       int&nbsp;cost)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lw</CODE> - <DD><CODE>rw</CODE> - <DD><CODE>le</CODE> - <DD><CODE>re</CODE> - <DD><CODE>cost</CODE> - 
<DT><B>Returns:</B><DD>hash used in this.ctable<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#lw"><CODE>TableConnector.lw</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#rw"><CODE>TableConnector.rw</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#le"><CODE>TableConnector.le</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#re"><CODE>TableConnector.re</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#cost"><CODE>TableConnector.cost</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="table_pointer(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int)"><!-- --></A><H3>
table_pointer</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/TableConnector.html" title="class in net.sf.jlinkgrammar">TableConnector</A> <B>table_pointer</B>(int&nbsp;lw,
                                           int&nbsp;rw,
                                           <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
                                           <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
                                           int&nbsp;cost)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lw</CODE> - <DD><CODE>rw</CODE> - <DD><CODE>le</CODE> - <DD><CODE>re</CODE> - <DD><CODE>cost</CODE> - 
<DT><B>Returns:</B><DD>the pointer to this info, null if not there<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#lw"><CODE>TableConnector.lw</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#rw"><CODE>TableConnector.rw</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#le"><CODE>TableConnector.le</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#re"><CODE>TableConnector.re</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#cost"><CODE>TableConnector.cost</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="table_store(int, int, net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, int, int)"><!-- --></A><H3>
table_store</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/TableConnector.html" title="class in net.sf.jlinkgrammar">TableConnector</A> <B>table_store</B>(int&nbsp;lw,
                                         int&nbsp;rw,
                                         <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;le,
                                         <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;re,
                                         int&nbsp;cost,
                                         int&nbsp;count)</PRE>
<DL>
<DD>Stores the value in the table this.ctable.  Assumes it's not already there
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lw</CODE> - <DD><CODE>rw</CODE> - <DD><CODE>le</CODE> - <DD><CODE>re</CODE> - <DD><CODE>cost</CODE> - <DD><CODE>count</CODE> - 
<DT><B>Returns:</B><DD>a new TableConnector<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#lw"><CODE>TableConnector.lw</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#rw"><CODE>TableConnector.rw</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#le"><CODE>TableConnector.le</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#re"><CODE>TableConnector.re</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#cost"><CODE>TableConnector.cost</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/TableConnector.html#next"><CODE>TableConnector.next</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/Sentence.html#init_table()"><CODE>init_table()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="init_fast_matcher()"><!-- --></A><H3>
init_fast_matcher</H3>
<PRE>
public void <B>init_fast_matcher</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="left_disjunct_list_length(net.sf.jlinkgrammar.Disjunct)"><!-- --></A><H3>
left_disjunct_list_length</H3>
<PRE>
public static int <B>left_disjunct_list_length</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>d</CODE> - 
<DT><B>Returns:</B><DD>the number of disjuncts in the list that have non-null
           left connector lists</DL>
</DD>
</DL>
<HR>

<A NAME="right_disjunct_list_length(net.sf.jlinkgrammar.Disjunct)"><!-- --></A><H3>
right_disjunct_list_length</H3>
<PRE>
public static int <B>right_disjunct_list_length</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</PRE>
<DL>
<DD>the number of disjuncts in the list that have non-null
           right connector lists
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>d</CODE> - 
<DT><B>Returns:</B><DD>the number of disjuncts in the list that have non-null
           right connector lists</DL>
</DD>
</DL>
<HR>

<A NAME="put_into_match_table(int, net.sf.jlinkgrammar.MatchNode[], net.sf.jlinkgrammar.Disjunct, net.sf.jlinkgrammar.Connector, int)"><!-- --></A><H3>
put_into_match_table</H3>
<PRE>
public static void <B>put_into_match_table</B>(int&nbsp;size,
                                        <A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>[]&nbsp;t,
                                        <A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d,
                                        <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                                        int&nbsp;dir)</PRE>
<DL>
<DD>The disjunct d (whose left or right pointer points to c) is put
           into the appropriate hash table
<p>
           dir =  1, we're putting this into a right table.
<p>
           dir = -1, we're putting this into a left table.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - <DD><CODE>t</CODE> - <DD><CODE>d</CODE> - <DD><CODE>c</CODE> - <DD><CODE>dir</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="fast_match_hash(net.sf.jlinkgrammar.Connector)"><!-- --></A><H3>
fast_match_hash</H3>
<PRE>
public static int <B>fast_match_hash</B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c)</PRE>
<DL>
<DD>This hash function only looks at the leading upper case letters of
           the connector string, and the label fields.  This ensures that if two
           strings match (formally), then they must hash to the same place.
           The answer must be masked to the appropriate table size.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - 
<DT><B>Returns:</B><DD>the index into the hash table</DL>
</DD>
</DL>
<HR>

<A NAME="add_to_right_table_list(net.sf.jlinkgrammar.MatchNode, net.sf.jlinkgrammar.MatchNode)"><!-- --></A><H3>
add_to_right_table_list</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A> <B>add_to_right_table_list</B>(<A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>&nbsp;m,
                                                <A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>&nbsp;l)</PRE>
<DL>
<DD>Adds the match node m to the sorted list of match nodes l.
           The parameter dir determines the order of the sorting to be used.
           Makes the list sorted from smallest to largest.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>m</CODE> - the node to add<DD><CODE>l</CODE> - the node to which we are to add m on the right
<DT><B>Returns:</B><DD>The matched node's right index</DL>
</DD>
</DL>
<HR>

<A NAME="add_to_left_table_list(net.sf.jlinkgrammar.MatchNode, net.sf.jlinkgrammar.MatchNode)"><!-- --></A><H3>
add_to_left_table_list</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A> <B>add_to_left_table_list</B>(<A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>&nbsp;m,
                                               <A HREF="../../../net/sf/jlinkgrammar/MatchNode.html" title="class in net.sf.jlinkgrammar">MatchNode</A>&nbsp;l)</PRE>
<DL>
<DD>Adds the match node m to the sorted list of match nodes l.
           The parameter dir determines the order of the sorting to be used.
           Makes the list sorted from largest to smallest
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>m</CODE> - the node to add<DD><CODE>l</CODE> - the node to which we are to add m on the right
<DT><B>Returns:</B><DD>The matched node's left index</DL>
</DD>
</DL>
<HR>

<A NAME="build_parse_set(int, net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
build_parse_set</H3>
<PRE>
public boolean <B>build_parse_set</B>(int&nbsp;cost,
                               <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD>This is the top level call that computes the whole parse_set.  It
      points whole_set at the result.  It creates the necessary hash
      table (x_table) which will be freed at the same time the
      whole_set is freed.
 <p>
      It also assumes that count() has been run, and that hash table is
      filled with the values thus computed.  Therefore this function
      must be structured just like parse() (the main function for
      count()).
 <p>
      If the number of linkages gets huge, then the counts can overflow.
      We check if this has happened when verifying the parse set.
      This routine returns true iff overflowed occurred.
 <p>
 This method modifies this.loca-sent, this.parse_info
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cost</CODE> - <DD><CODE>opts</CODE> - 
<DT><B>Returns:</B><DD>the result of ParseInfo.verify_set<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/ParseInfo.html#verify_set()"><CODE>ParseInfo.verify_set()</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/Word.html" title="class in net.sf.jlinkgrammar"><CODE>Word</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/Sentence.html#parse_info"><CODE>parse_info</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="build_sentence_disjuncts(net.sf.jlinkgrammar.ParseOptions, int)"><!-- --></A><H3>
build_sentence_disjuncts</H3>
<PRE>
public void <B>build_sentence_disjuncts</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                                     int&nbsp;cost_cutoff)</PRE>
<DL>
<DD>We've already built the sentence expressions.  This turns them into
           disjuncts.  The method modifies this.word by adding the disjuncts
     to word[index].d
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - - refers to this.cost_cutoff that is set from ParseInfo pi
                      at object creation. TODO - Fix where ParseInfo is kept.<DD><CODE>cost_cutoff</CODE> - <DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#word"><CODE>word</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/Word.html#d"><CODE>Word.d</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="build_disjuncts_for_XNode(net.sf.jlinkgrammar.ParseOptions, net.sf.jlinkgrammar.XNode, int)"><!-- --></A><H3>
build_disjuncts_for_XNode</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A> <B>build_disjuncts_for_XNode</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                                          <A HREF="../../../net/sf/jlinkgrammar/XNode.html" title="class in net.sf.jlinkgrammar">XNode</A>&nbsp;x,
                                          int&nbsp;cost_cutoff)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - unused - refers to this.cost_cutoff that is set from ParseInfo pi
                      at object creation. TODO - Fix where ParseInfo is kept.<DD><CODE>x</CODE> - is the Word  expression list node<DD><CODE>cost_cutoff</CODE> - 
<DT><B>Returns:</B><DD>a linked list of dijuncts for the named node<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/Word.html#x"><CODE>Word.x</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sentence_contains_conjunction()"><!-- --></A><H3>
sentence_contains_conjunction</H3>
<PRE>
public boolean <B>sentence_contains_conjunction</B>()</PRE>
<DL>
<DD>We've already built the sentence expressions.  This turns them into
           disjuncts.  Assumes
           is_conjunction[] has been initialized.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if there are conjunctions</DL>
</DD>
</DL>
<HR>

<A NAME="print_disjunct_counts(net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
print_disjunct_counts</H3>
<PRE>
public void <B>print_disjunct_counts</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="post_process_linkages(net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
post_process_linkages</H3>
<PRE>
public void <B>post_process_linkages</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD>This is another top level call.  It is called by default when you create
 a new Linkage object.  If you want another postprocessor this is the method
 to call.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - <DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/Linkage.html#Linkage(int, net.sf.jlinkgrammar.Sentence, net.sf.jlinkgrammar.ParseOptions)"><CODE>Linkage.Linkage(int, Sentence, ParseOptions)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="fill_patch_array_DIS(net.sf.jlinkgrammar.DISNode, net.sf.jlinkgrammar.LinksToPatch)"><!-- --></A><H3>
fill_patch_array_DIS</H3>
<PRE>
public void <B>fill_patch_array_DIS</B>(<A HREF="../../../net/sf/jlinkgrammar/DISNode.html" title="class in net.sf.jlinkgrammar">DISNode</A>&nbsp;dn,
                                 <A HREF="../../../net/sf/jlinkgrammar/LinksToPatch.html" title="class in net.sf.jlinkgrammar">LinksToPatch</A>&nbsp;ltp)</PRE>
<DL>
<DD>Patches up appropriate links in the patch_array for this DISNode
 and this patch list.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dn</CODE> - <DD><CODE>ltp</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="fill_patch_array_CON(net.sf.jlinkgrammar.CONNode, net.sf.jlinkgrammar.LinksToPatch)"><!-- --></A><H3>
fill_patch_array_CON</H3>
<PRE>
public void <B>fill_patch_array_CON</B>(<A HREF="../../../net/sf/jlinkgrammar/CONNode.html" title="class in net.sf.jlinkgrammar">CONNode</A>&nbsp;cn,
                                 <A HREF="../../../net/sf/jlinkgrammar/LinksToPatch.html" title="class in net.sf.jlinkgrammar">LinksToPatch</A>&nbsp;ltp)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cn</CODE> - <DD><CODE>ltp</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="analyze_fat_linkage(net.sf.jlinkgrammar.ParseOptions, int)"><!-- --></A><H3>
analyze_fat_linkage</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/LinkageInfo.html" title="class in net.sf.jlinkgrammar">LinkageInfo</A> <B>analyze_fat_linkage</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                                       int&nbsp;analyze_pass)</PRE>
<DL>
<DD>This uses link_array.  It enumerates and post-processes
           all the linkages represented by this one.  We know this contains
           at least one fat link.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - <DD><CODE>analyze_pass</CODE> - 
<DT><B>Returns:</B><DD>a new LinkageInfo object based on this.parse_info<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/ParseInfo.html" title="class in net.sf.jlinkgrammar"><CODE>ParseInfo</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="post_process_scan_linkage(net.sf.jlinkgrammar.Postprocessor, net.sf.jlinkgrammar.ParseOptions, net.sf.jlinkgrammar.Sublinkage)"><!-- --></A><H3>
post_process_scan_linkage</H3>
<PRE>
public void <B>post_process_scan_linkage</B>(<A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar">Postprocessor</A>&nbsp;pp,
                                      <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                                      <A HREF="../../../net/sf/jlinkgrammar/Sublinkage.html" title="class in net.sf.jlinkgrammar">Sublinkage</A>&nbsp;sublinkage)</PRE>
<DL>
<DD>During a first pass (prior to actual post-processing of the linkages
           of a sentence), call this once for every generated linkage. Here we
           simply maintain a set of "seen" link names for rule pruning later on
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pp</CODE> - <DD><CODE>opts</CODE> - <DD><CODE>sublinkage</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="prune_irrelevant_rules(net.sf.jlinkgrammar.ParseOptions, net.sf.jlinkgrammar.Postprocessor)"><!-- --></A><H3>
prune_irrelevant_rules</H3>
<PRE>
public void <B>prune_irrelevant_rules</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                                   <A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar">Postprocessor</A>&nbsp;pp)</PRE>
<DL>
<DD>call this (a) after having called post_process_scan_linkage() on all
           generated linkages, but (b) before calling post_process() on any
           particular linkage. Here we mark all rules which we know (from having
           accumulated a set of link names appearing in *any* linkage) won't
           ever be needed.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - <DD><CODE>pp</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="post_process(net.sf.jlinkgrammar.Postprocessor, net.sf.jlinkgrammar.ParseOptions, net.sf.jlinkgrammar.Sublinkage, boolean)"><!-- --></A><H3>
post_process</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/PPNode.html" title="class in net.sf.jlinkgrammar">PPNode</A> <B>post_process</B>(<A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar">Postprocessor</A>&nbsp;pp,
                           <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                           <A HREF="../../../net/sf/jlinkgrammar/Sublinkage.html" title="class in net.sf.jlinkgrammar">Sublinkage</A>&nbsp;sublinkage,
                           boolean&nbsp;cleanup)</PRE>
<DL>
<DD>Takes a sublinkage and returns:
<ul>
 <li>      . for each link, the domain structure of that link
 <li>      . a list of the violation strings
 </ul>
 <p>
           NB: sublinkage.link[i].l=-1 means that this connector is to be ignored
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pp</CODE> - <DD><CODE>opts</CODE> - <DD><CODE>sublinkage</CODE> - <DD><CODE>cleanup</CODE> - 
<DT><B>Returns:</B><DD>a PPNode for the linkage in the given postprocessor or null if none or the postprocessor is not valid</DL>
</DD>
</DL>
<HR>

<A NAME="compute_pp_link_array_connectors(net.sf.jlinkgrammar.Sublinkage)"><!-- --></A><H3>
compute_pp_link_array_connectors</H3>
<PRE>
public void <B>compute_pp_link_array_connectors</B>(<A HREF="../../../net/sf/jlinkgrammar/Sublinkage.html" title="class in net.sf.jlinkgrammar">Sublinkage</A>&nbsp;sublinkage)</PRE>
<DL>
<DD>This takes as input link_array[], sublinkage.link[].l and
           sublinkage.link[].r (and also has_fat_down[word], which has been
           computed in a prior call to is_canonical()), and from these
           computes sublinkage.link[].lc and .rc.  We assume these have
           been initialized with the values from link_array.  We also assume
           that there are fat links.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sublinkage</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="compute_pp_link_names(net.sf.jlinkgrammar.Sublinkage)"><!-- --></A><H3>
compute_pp_link_names</H3>
<PRE>
public void <B>compute_pp_link_names</B>(<A HREF="../../../net/sf/jlinkgrammar/Sublinkage.html" title="class in net.sf.jlinkgrammar">Sublinkage</A>&nbsp;sublinkage)</PRE>
<DL>
<DD>This fills in the sublinkage.link[].name field.  We assume that
           link_array[].name have already been filled in.  As above, in the
           standard case, the name is just the GCD of the two end points.
           If pluralization has occurred, then we want to use the name
           already in link_array[].name.  We detect this in two ways.
           If the endpoints don't match, then we know pluralization
           has occured.  If they do, but the name in link_array[].name
           is *less* restrictive, then pluralization must have occured.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sublinkage</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="copy_d_type(net.sf.jlinkgrammar.DTypeList)"><!-- --></A><H3>
copy_d_type</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/DTypeList.html" title="class in net.sf.jlinkgrammar">DTypeList</A> <B>copy_d_type</B>(<A HREF="../../../net/sf/jlinkgrammar/DTypeList.html" title="class in net.sf.jlinkgrammar">DTypeList</A>&nbsp;dtl)</PRE>
<DL>
<DD>Copy the named Domain Type List and return a copy
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dtl</CODE> - 
<DT><B>Returns:</B><DD>head of the DTypeList</DL>
</DD>
</DL>
<HR>

<A NAME="build_andlist()"><!-- --></A><H3>
build_andlist</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/AndList.html" title="class in net.sf.jlinkgrammar">AndList</A> <B>build_andlist</B>()</PRE>
<DL>
<DD>This function computes the "and cost", resulting from inequalities in the word.size() of
           and-list elements. It also computes other information used to construct the "andlist"
           structure of linkage_info.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>list of conunctions<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/AndData.html" title="class in net.sf.jlinkgrammar"><CODE>for a detailed explanation of And</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="analyze_thin_linkage(net.sf.jlinkgrammar.ParseOptions, int)"><!-- --></A><H3>
analyze_thin_linkage</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/LinkageInfo.html" title="class in net.sf.jlinkgrammar">LinkageInfo</A> <B>analyze_thin_linkage</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                                        int&nbsp;analyze_pass)</PRE>
<DL>
<DD>This uses link_array.  It post-processes
           this linkage, and prints the appropriate thing.  There are no fat
           links in it.
 <p>
 The code can be used to generate the "islands" array. For this to work,
           however, you have to call "build_digraph" first (as in analyze_fat_linkage).
           and then "free_digraph". For some reason this causes a space leak.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - <DD><CODE>analyze_pass</CODE> - 
<DT><B>Returns:</B><DD>a valid LinkageInfo</DL>
</DD>
</DL>
<HR>

<A NAME="is_canonical_linkage()"><!-- --></A><H3>
is_canonical_linkage</H3>
<PRE>
public boolean <B>is_canonical_linkage</B>()</PRE>
<DL>
<DD>uses link_array[], chosen_disjuncts[], has_fat_down[].
           It assumes that there is a fat link in the current linkage.
           See AndData() for more information about how it works
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if it is cannonical<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/AndData.html" title="class in net.sf.jlinkgrammar"><CODE>AndData</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="strictly_smaller(java.lang.String, java.lang.String)"><!-- --></A><H3>
strictly_smaller</H3>
<PRE>
public boolean <B>strictly_smaller</B>(java.lang.String&nbsp;s,
                                java.lang.String&nbsp;t)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - <DD><CODE>t</CODE> - 
<DT><B>Returns:</B><DD>true if string s represents a strictly smaller match set
           than does t</DL>
</DD>
</DL>
<HR>

<A NAME="find_subdisjunct(net.sf.jlinkgrammar.Disjunct, int)"><!-- --></A><H3>
find_subdisjunct</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A> <B>find_subdisjunct</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;dis,
                                 int&nbsp;label)</PRE>
<DL>
<DD>Find the specific disjunct of in label_table[label]
           which corresponds to dis.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dis</CODE> - a disjunct in the label_table<DD><CODE>label</CODE> - lable_table containing a disjunct
<DT><B>Returns:</B><DD>first disjunct</DL>
</DD>
</DL>
<HR>

<A NAME="build_image_array()"><!-- --></A><H3>
build_image_array</H3>
<PRE>
public void <B>build_image_array</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="size_of_sentence_expressions()"><!-- --></A><H3>
size_of_sentence_expressions</H3>
<PRE>
public int <B>size_of_sentence_expressions</B>()</PRE>
<DL>
<DD>Computes and returns the number of connectors in all of the expressions
           of the sentence.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the number of connectors in all of the expressions</DL>
</DD>
</DL>
<HR>

<A NAME="clean_up_expressions(int)"><!-- --></A><H3>
clean_up_expressions</H3>
<PRE>
public void <B>clean_up_expressions</B>(int&nbsp;w)</PRE>
<DL>
<DD>This removes the expressions that are empty from the list corresponding
  to word w of the sentence.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="expression_prune(net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
expression_prune</H3>
<PRE>
public void <B>expression_prune</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="print_expression_sizes(net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
print_expression_sizes</H3>
<PRE>
public void <B>print_expression_sizes</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="zero_S()"><!-- --></A><H3>
zero_S</H3>
<PRE>
public static void <B>zero_S</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="free_S()"><!-- --></A><H3>
free_S</H3>
<PRE>
public static void <B>free_S</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="insert_S(net.sf.jlinkgrammar.Connector)"><!-- --></A><H3>
insert_S</H3>
<PRE>
public static void <B>insert_S</B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="hash_S(net.sf.jlinkgrammar.Connector)"><!-- --></A><H3>
hash_S</H3>
<PRE>
public static int <B>hash_S</B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c)</PRE>
<DL>
<DD>This hash function only looks at the leading upper case letters of
           the connector string, and the label fields.  This ensures that if two
           strings match (formally), then they must hash to the same place.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - 
<DT><B>Returns:</B><DD>the hash  of the connector</DL>
</DD>
</DL>
<HR>

<A NAME="print_parse_statistics(net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
print_parse_statistics</H3>
<PRE>
public void <B>print_parse_statistics</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="matches_S(net.sf.jlinkgrammar.Connector, int)"><!-- --></A><H3>
matches_S</H3>
<PRE>
public boolean <B>matches_S</B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                         int&nbsp;dir)</PRE>
<DL>
<DD>returns true if c can match anything in the set S
 because of the horrible kludge, prune match is assymetric, and
 direction is '-' if this is an l.r pass, and '+' if an r.l pass.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - <DD><CODE>dir</CODE> - 
<DT><B>Returns:</B><DD>returns true if c can match anything in the set S</DL>
</DD>
</DL>
<HR>

<A NAME="sentence_get_word(int)"><!-- --></A><H3>
sentence_get_word</H3>
<PRE>
public java.lang.String <B>sentence_get_word</B>(int&nbsp;index)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - 
<DT><B>Returns:</B><DD>the String form of the word at the named index in this.word<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/Sentence.html#word"><CODE>word</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sentence_null_count()"><!-- --></A><H3>
sentence_null_count</H3>
<PRE>
public int <B>sentence_null_count</B>()</PRE>
<DL>
<DD><DL>

<DT><B>Returns:</B><DD>the number of null linkages?</DL>
</DD>
</DL>
<HR>

<A NAME="sentence_num_linkages_found()"><!-- --></A><H3>
sentence_num_linkages_found</H3>
<PRE>
public int <B>sentence_num_linkages_found</B>()</PRE>
<DL>
<DD><DL>

<DT><B>Returns:</B><DD>the number of linkages found</DL>
</DD>
</DL>
<HR>

<A NAME="sentence_num_valid_linkages()"><!-- --></A><H3>
sentence_num_valid_linkages</H3>
<PRE>
public int <B>sentence_num_valid_linkages</B>()</PRE>
<DL>
<DD><DL>

<DT><B>Returns:</B><DD>the number of valid linkages</DL>
</DD>
</DL>
<HR>

<A NAME="sentence_num_linkages_post_processed()"><!-- --></A><H3>
sentence_num_linkages_post_processed</H3>
<PRE>
public int <B>sentence_num_linkages_post_processed</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sentence_num_violations(int)"><!-- --></A><H3>
sentence_num_violations</H3>
<PRE>
public int <B>sentence_num_violations</B>(int&nbsp;i)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sentence_disjunct_cost(int)"><!-- --></A><H3>
sentence_disjunct_cost</H3>
<PRE>
public int <B>sentence_disjunct_cost</B>(int&nbsp;i)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="set_has_fat_down()"><!-- --></A><H3>
set_has_fat_down</H3>
<PRE>
public boolean <B>set_has_fat_down</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="compute_link_names()"><!-- --></A><H3>
compute_link_names</H3>
<PRE>
public void <B>compute_link_names</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="strictly_smaller_name(java.lang.String, java.lang.String)"><!-- --></A><H3>
strictly_smaller_name</H3>
<PRE>
public static boolean <B>strictly_smaller_name</B>(java.lang.String&nbsp;s,
                                            java.lang.String&nbsp;t)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="intersect_strings(java.lang.String, java.lang.String)"><!-- --></A><H3>
intersect_strings</H3>
<PRE>
public static java.lang.String <B>intersect_strings</B>(java.lang.String&nbsp;s,
                                                 java.lang.String&nbsp;t)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="free_sentence_disjuncts()"><!-- --></A><H3>
free_sentence_disjuncts</H3>
<PRE>
public void <B>free_sentence_disjuncts</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="free_HT()"><!-- --></A><H3>
free_HT</H3>
<PRE>
public void <B>free_HT</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="free_LT()"><!-- --></A><H3>
free_LT</H3>
<PRE>
public void <B>free_LT</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="free_AND_tables()"><!-- --></A><H3>
free_AND_tables</H3>
<PRE>
public void <B>free_AND_tables</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="free_parse_set()"><!-- --></A><H3>
free_parse_set</H3>
<PRE>
public void <B>free_parse_set</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="install_special_conjunctive_connectors()"><!-- --></A><H3>
install_special_conjunctive_connectors</H3>
<PRE>
public void <B>install_special_conjunctive_connectors</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sentence_contains(java.lang.String)"><!-- --></A><H3>
sentence_contains</H3>
<PRE>
public boolean <B>sentence_contains</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="glom_comma_connector(net.sf.jlinkgrammar.Disjunct)"><!-- --></A><H3>
glom_comma_connector</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A> <B>glom_comma_connector</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</PRE>
<DL>
<DD>This file contains the functions for massaging disjuncts of the
   sentence in special ways having to do with conjunctions.
   The only function called from the outside world is
   install_special_conjunctive_connectors()
 <p>
   It would be nice if this code was written more transparently.  In
   other words, there should be some fairly general functions that
   manipulate disjuncts, and take words like "neither" etc as input
   parameters, so as to encapsulate the changes being made for special
   words.  This would not be too hard to do, but it's not a high priority.
       -DS 3/98
<p>

 There's a problem with installing "...but...", "not only...but...", and
   "not...but...", which is that the current comma mechanism will allow
   a list separated by commas.  "Not only John, Mary but Jim came"
   The best way to prevent this is to make it impossible for the comma
   to attach to the "but", via some sort of additional subscript on commas.
<p>
   I can't think of a good way to prevent this.
<p>
<p>

 The following functions all do slightly different variants of the
   following thing:
<p>
   Catenate to the disjunct list pointed to by d, a new disjunct list.
   The new list is formed by copying the old list, and adding the new
   connector somewhere in the old disjunct, for disjuncts that satisfy
   certain conditions
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="glom_aux_connector(net.sf.jlinkgrammar.Disjunct, int, boolean)"><!-- --></A><H3>
glom_aux_connector</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A> <B>glom_aux_connector</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d,
                                          int&nbsp;label,
                                          boolean&nbsp;necessary)</PRE>
<DL>
<DD>In this case the connector is to connect to the "either", "neither",
           "not", or some auxilliary d to the current which is a conjunction.
           Only gets added next to a fat link, but before it (not after it)
           In the case of "nor", we don't create new disjuncts, we merely modify
           existing ones.  This forces the fat link uses of "nor" to
           use a neither.  (Not the case with "or".)  If necessary=false, then
           duplication is done, otherwise it isn't
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="add_one_connector(int, int, java.lang.String, net.sf.jlinkgrammar.Disjunct)"><!-- --></A><H3>
add_one_connector</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A> <B>add_one_connector</B>(int&nbsp;label,
                                         int&nbsp;dir,
                                         java.lang.String&nbsp;cs,
                                         <A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</PRE>
<DL>
<DD>This adds one connector onto the beginning of the left (or right)
           connector list of d.  The label and string of the connector are
           specified
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="special_disjunct(int, int, java.lang.String, java.lang.String)"><!-- --></A><H3>
special_disjunct</H3>
<PRE>
public static <A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A> <B>special_disjunct</B>(int&nbsp;label,
                                        int&nbsp;dir,
                                        java.lang.String&nbsp;cs,
                                        java.lang.String&nbsp;ds)</PRE>
<DL>
<DD>Builds a new disjunct with one connector pointing in direction dir
           (which is '+' or '-').  The label and string of the connector
           are specified, as well as the string of the disjunct.
           The next pointer of the new disjunct set to null, so it can be
           regarded as a list.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="pp_prune(net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
pp_prune</H3>
<PRE>
public int <B>pp_prune</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="pp_and_power_prune(int, net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
pp_and_power_prune</H3>
<PRE>
public void <B>pp_and_power_prune</B>(int&nbsp;mode,
                               <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="delete_unmarked_disjuncts()"><!-- --></A><H3>
delete_unmarked_disjuncts</H3>
<PRE>
public void <B>delete_unmarked_disjuncts</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clean_up(int)"><!-- --></A><H3>
clean_up</H3>
<PRE>
public void <B>clean_up</B>(int&nbsp;w)</PRE>
<DL>
<DD>Step three of the sentence_parse operation - pruning
 <p>
      The algorithms in this file prune disjuncts from the disjunct list
      of the sentence that can be elimininated by a simple checks.  The first
      check works as follows:
 <p>
      A series of passes are made through the sentence, alternating
      left-to-right and right-to-left.  Consider the left-to-right pass (the
      other is symmetric).  A set S of connectors is maintained (initialized
      to be empty).  Now the disjuncts of the current word are processed.
      If a given disjunct's left pointing connectors have the property that
      at least one of them has no connector in S to which it can be matched,
      then that disjunct is deleted. Now the set S is augmented by the right
      connectors of the remaining disjuncts of that word.  This completes
      one word.  The process continues through the words from left to right.
      Alternate passes are made until no disjunct is deleted.
  <p>
      It worries me a little that if there are some really huge disjuncts lists,
      then this process will probably do nothing.  (This fear turns out to be
      unfounded.)
  <p>
      Notes:  Power pruning will not work if applied before generating the
      "and" disjuncts.  This is because certain of it's tricks don't work.
      Think about this, and finish this note later....
      Also, currently I use the standard connector match procedure instead
      of the pruning one, since I know power pruning will not be used before
      and generation.  Replace this to allow power pruning to work before
      generating and disjuncts.
   <p>
      Currently it seems that normal pruning, power pruning, and generation,
      pruning, and power pruning (after "and" generation) and parsing take
      about the same amount of time.  This is why doing power pruning before
      "and" generation might be a very good idea.
  <p>
      New idea:  Suppose all the disjuncts of a word have a connector of type
      c pointing to the right.  And further, suppose that there is exactly one
      word to its right containing that type of connector pointing to the left.
      Then all the other disjuncts on the latter word can be deleted.
      (This situation is created by the processing of "either...or", and by
      the extra disjuncts added to a "," neighboring a conjunction.)
   <p>
 see AndData()
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="count_disjuncts_in_sentence()"><!-- --></A><H3>
count_disjuncts_in_sentence</H3>
<PRE>
public int <B>count_disjuncts_in_sentence</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="power_prune(int, net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
power_prune</H3>
<PRE>
public int <B>power_prune</B>(int&nbsp;mode,
                       <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD>Here is what you've been waiting for: POWER-PRUNE
 <p>
   The kinds of constraints it checks for are the following:
 <p>
   1) successive connectors on the same disjunct have to go to
      nearer and nearer words.
 <p>
   2) two deep connectors cannot attach to eachother
      (A connectors is deep if it is not the first in its list, it
      is shallow if it is the first in its list, it is deepest if it
      is the last on its list.)
 <p>
   3) on two adjacent words, a pair of connectors can be used
      only if they're the deepest ones on their disjuncts
 <p>
   4) on two non-adjacent words, a pair of connectors can be used only
      if not [both of them are the deepest].
 <p>
   The data structure consists of a pair of hash tables on every word.
   Each bucket of a hash table has a list of pointers to connectors.
   These nodes also store if the chosen connector is shallow.
 <p>
 <p>
      As with normal pruning, we make alternate left.right and right.left
      passes.  In the R.L pass, when we're on a word w, we make use of
      all the left-pointing hash tables on the words to the right of w.
      After the pruning on this word, we build the left-pointing hash table
      this word.  This guarantees idempotence of the pass -- after doing an
      L.R, doing another would change nothing.
 <p>
      Each connector has an integer c_word field.  This refers to the closest
      word that it could be connected to.  These are initially determined by
      how deep the connector is.  For example, a deepest connector can connect
      to the neighboring word, so its c_word field is w+1 (w-1 if this is a left
      pointing connector).  It's neighboring shallow connector has a c_word
      value of w+2, etc.
 <p>
      The pruning process adjusts these c_word values as it goes along,
      accumulating information about any way of linking this sentence.
      The pruning process stops only after no disjunct is deleted and no
      c_word values change.

 <p>
 The difference between RUTHLESS and GENTLE power pruning is simply
      that GENTLE uses the deletable region array, and RUTHLESS does not.
      So we can get the effect of these two different methods simply by
      always unsuring that deletable[][] has been defined.  With nothing
      deletable, this is equivalent to RUTHLESS.   --DS, 7/97
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clean_table(int, net.sf.jlinkgrammar.CList[])"><!-- --></A><H3>
clean_table</H3>
<PRE>
public void <B>clean_table</B>(int&nbsp;size,
                        <A HREF="../../../net/sf/jlinkgrammar/CList.html" title="class in net.sf.jlinkgrammar">CList</A>[]&nbsp;t)</PRE>
<DL>
<DD>This runs through all the connectors in this table, and eliminates those
           who are obsolete.  The word fields of an obsolete one has been set to
           BAD_WORD.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="left_connector_list_update(net.sf.jlinkgrammar.Connector, int, int, boolean)"><!-- --></A><H3>
left_connector_list_update</H3>
<PRE>
public int <B>left_connector_list_update</B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                                      int&nbsp;word_c,
                                      int&nbsp;w,
                                      boolean&nbsp;shallow)</PRE>
<DL>
<DD>take this connector list, and try to match it with the words
           w-1, w-2, w-3...Returns the word to which the first connector of the
           list could possibly be matched.  If c is null, returns w.  If there
           is no way to match this list, it returns a negative number.
           If it does find a way to match it, it updates the c.word fields
           correctly.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="right_connector_list_update(net.sf.jlinkgrammar.Connector, int, int, boolean)"><!-- --></A><H3>
right_connector_list_update</H3>
<PRE>
public int <B>right_connector_list_update</B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                                       int&nbsp;word_c,
                                       int&nbsp;w,
                                       boolean&nbsp;shallow)</PRE>
<DL>
<DD>take this connector list, and try to match it with the words
           w+1, w+2, w+3...Returns the word to which the first connector of the
           list could possibly be matched.  If c is null, returns w.  If there
           is no way to match this list, it returns a number greater than N_words-1
           If it does find a way to match it, it updates the c.word fields
           correctly.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="prune(net.sf.jlinkgrammar.ParseOptions)"><!-- --></A><H3>
prune</H3>
<PRE>
public void <B>prune</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="set_dist_fields(net.sf.jlinkgrammar.Connector, int, int)"><!-- --></A><H3>
set_dist_fields</H3>
<PRE>
public int <B>set_dist_fields</B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                           int&nbsp;w,
                           int&nbsp;delta)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="possible_connection(net.sf.jlinkgrammar.Connector, net.sf.jlinkgrammar.Connector, boolean, boolean, int, int)"><!-- --></A><H3>
possible_connection</H3>
<PRE>
public boolean <B>possible_connection</B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;lc,
                                   <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;rc,
                                   boolean&nbsp;lshallow,
                                   boolean&nbsp;rshallow,
                                   int&nbsp;lword,
                                   int&nbsp;rword)</PRE>
<DL>
<DD>this takes two connectors (and whether these are shallow or not)
           (and the two words that these came from) and returns true if it is
           possible for these two to match based on local considerations.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="right_table_search(int, net.sf.jlinkgrammar.Connector, boolean, int)"><!-- --></A><H3>
right_table_search</H3>
<PRE>
public boolean <B>right_table_search</B>(int&nbsp;w,
                                  <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                                  boolean&nbsp;shallow,
                                  int&nbsp;word_c)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="left_table_search(int, net.sf.jlinkgrammar.Connector, boolean, int)"><!-- --></A><H3>
left_table_search</H3>
<PRE>
public boolean <B>left_table_search</B>(int&nbsp;w,
                                 <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                                 boolean&nbsp;shallow,
                                 int&nbsp;word_c)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="init_power()"><!-- --></A><H3>
init_power</H3>
<PRE>
public void <B>init_power</B>()</PRE>
<DL>
<DD>allocates and builds the initial power hash tables
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="left_connector_count(net.sf.jlinkgrammar.Disjunct)"><!-- --></A><H3>
left_connector_count</H3>
<PRE>
public int <B>left_connector_count</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</PRE>
<DL>
<DD>returns the number of connectors in the left lists of the disjuncts.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="right_connector_count(net.sf.jlinkgrammar.Disjunct)"><!-- --></A><H3>
right_connector_count</H3>
<PRE>
public int <B>right_connector_count</B>(<A HREF="../../../net/sf/jlinkgrammar/Disjunct.html" title="class in net.sf.jlinkgrammar">Disjunct</A>&nbsp;d)</PRE>
<DL>
<DD>returns the number of connectors in the right lists of the disjuncts.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="power_hash(net.sf.jlinkgrammar.Connector)"><!-- --></A><H3>
power_hash</H3>
<PRE>
public int <B>power_hash</B>(<A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c)</PRE>
<DL>
<DD>This hash function only looks at the leading upper case letters of
           the connector string, and the label fields.  This ensures that if two
           strings match (formally), then they must hash to the same place.
           The answer must be masked to the appropriate table size.

           This is exactly the same hash function used in fast-match.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="put_into_power_table(int, net.sf.jlinkgrammar.CList[], net.sf.jlinkgrammar.Connector, boolean)"><!-- --></A><H3>
put_into_power_table</H3>
<PRE>
public void <B>put_into_power_table</B>(int&nbsp;size,
                                 <A HREF="../../../net/sf/jlinkgrammar/CList.html" title="class in net.sf.jlinkgrammar">CList</A>[]&nbsp;t,
                                 <A HREF="../../../net/sf/jlinkgrammar/Connector.html" title="class in net.sf.jlinkgrammar">Connector</A>&nbsp;c,
                                 boolean&nbsp;shal)</PRE>
<DL>
<DD>The disjunct d (whose left or right pointer points to c) is put
           into the appropriate hash table
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="init_cms_table()"><!-- --></A><H3>
init_cms_table</H3>
<PRE>
public void <B>init_cms_table</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cms_hash(java.lang.String)"><!-- --></A><H3>
cms_hash</H3>
<PRE>
public int <B>cms_hash</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="match_in_cms_table(java.lang.String)"><!-- --></A><H3>
match_in_cms_table</H3>
<PRE>
public boolean <B>match_in_cms_table</B>(java.lang.String&nbsp;pp_match_name)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lookup_in_cms_table(java.lang.String)"><!-- --></A><H3>
lookup_in_cms_table</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/Cms.html" title="class in net.sf.jlinkgrammar">Cms</A> <B>lookup_in_cms_table</B>(java.lang.String&nbsp;str)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="insert_in_cms_table(java.lang.String)"><!-- --></A><H3>
insert_in_cms_table</H3>
<PRE>
public void <B>insert_in_cms_table</B>(java.lang.String&nbsp;str)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="delete_from_cms_table(java.lang.String)"><!-- --></A><H3>
delete_from_cms_table</H3>
<PRE>
public int <B>delete_from_cms_table</B>(java.lang.String&nbsp;str)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rule_satisfiable(net.sf.jlinkgrammar.PPLinkset)"><!-- --></A><H3>
rule_satisfiable</H3>
<PRE>
public boolean <B>rule_satisfiable</B>(<A HREF="../../../net/sf/jlinkgrammar/PPLinkset.html" title="class in net.sf.jlinkgrammar">PPLinkset</A>&nbsp;ls)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Resources.html" title="class in net.sf.jlinkgrammar"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../net/sf/jlinkgrammar/StartingLinkAndDomain.html" title="class in net.sf.jlinkgrammar"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/sf/jlinkgrammar/Sentence.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Sentence.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
