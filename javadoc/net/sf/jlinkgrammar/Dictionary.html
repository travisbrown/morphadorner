<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_12) on Thu Apr 30 16:01:38 CDT 2009 -->
<TITLE>
Dictionary (MorphAdorner)
</TITLE>

<META NAME="date" CONTENT="2009-04-30">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Dictionary (MorphAdorner)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Constituent.html" title="class in net.sf.jlinkgrammar"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/sf/jlinkgrammar/Dictionary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Dictionary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.sf.jlinkgrammar</FONT>
<BR>
Class Dictionary</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>net.sf.jlinkgrammar.Dictionary</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Dictionary</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
This is one of the core classes of the link grammar.  It associates a dictionary
 with a sentence. The First routine you have to call is.
Dictionary(ParseOptions opts, String dict_name, String pp_name, String cons_name, String affix_name)

 <p>
     The dictionary format:
 <p>
     In what follows:
       Every "%" symbol and everything after it is ignored on every line.
       Every newline or tab is replaced by a space.
  <p>
     The dictionary file is a sequence of ENTRIES.  Each ENTRY is one or
     more WORDS (a sequence of upper or lower case letters) separated by
     spaces, followed by a ":", followed by an EXPRESSION followed by a
     ";".  An EXPRESSION is a lisp expression where the functions are "&"
     or "and" or "|" or "or", and there are three types of parentheses:
     "()", "{}", and "[]".  The terminal symbols of this grammar are the
     connectors, which are strings of letters or numbers or *s.  (This
     description applies to the prefix form of the dictionary.  the current
     dictionary is written in infix form.  If the defined constant
     INFIX_NOTATION is defined, then infix is used otherwise prefix is used.)
 <p>
     The connector begins with an optinal @, which is followed by an upper
     case sequence of letters. Each subsequent *, lower case letter or
     number is a subscript. At the end is a + or - sign.  The "@" allows
     this connector to attach to one or more other connectors.
 <p>
     Here is a sample dictionary entry (in infix form):
 <p>
         gone:         T- & {&#064EV+};
  <p>
     (See our paper for more about how to interpret the meaning of the
     dictionary expressions.)
 <p>
     A previously defined word (such as "gone" above) may be used instead
     of a connector to specify the expression it was defined to be.  Of
     course, in this case, it must uniquely specify a word in the
     dictionary, and have been previously defined.
 <p>
     If a word is of the form "/foo", then the file current-dir/foo
     is a so-called word file, and is read in as a list of words.
     A word file is just a list of words separted by blanks or newlines.
  <p>
     A word that contains the character "_" defines an idiomatic use of
     the words separated by the "_".  For example "kind of" is an idiomatic
     expression, so a word "kind_of" is defined in the dictionary.
     Idomatic expressions of any number of words can be defined in this way.
     When the word "kind" is encountered, all the idiomatic uses of the word
     are considered.
 <p>
     An expresion enclosed in "[..]" is give a cost of 1.  This means
     that if any of the connectors inside the square braces are used,
     a cost of 1 is incurred.  (This cost is the first element of the cost
     vector printed when a sentence is parsed.)  Of course if something is
     inside of 10 levels of "[..]" then using it incurs a cost of 10.
     These costs are called "disjunct costs".  The linkages are printed out
     in order of non-increasing disjunct cost.
 <p>
     The expression "(A+ or ())" means that you can choose either "A+" or
     the empty expression "()", that is, that the connector "A+" is
     optional.  This is more compactly expressed as "{A+}".  In other words,
     curly braces indicate an optional expression.
 <p>
     The expression "(A+ or [])" is the same as that above, but there is a
     cost of 1 incurred for choosing not to use "A+".  The expression
     "(EXP1 & [EXP2])" is exactly the same as "[EXP1 & EXP2]".  The difference
     between "({[A+]} & B+)" and "([{A+}] & B+)" is that the latter always
     incurrs a cost of 1, while the former only gets a cost of 1 if "A+" is
     used.
  <p>
     The dictionary writer is not allowed to use connectors that begin in
     "ID".  This is reserved for the connectors automatically
     generated for idioms.
 <p>
 One more thing...
<p>
 <B>The Dictionary is a binary tree</b>
<p>
 The data structure storing the dictionary is simply a binary tree.
 There is one catch however.  The ordering of the words is not
 exactly the order given by strcmp.  It was necessary to
 modify the order to make it so that "make" < "make.n" < "make-up"
 The problem is that if some other string could  lie between '\0'
 and '.' (such as '-' which strcmp would give) then it makes it much
 harder to return all the strings that match a given word.
 For example, if "make-up" was inserted, then "make" was inserted
 the a search was done for "make.n", the obvious algorithm would
 not find the match.


 <CODE>
 int dict_compare(String s, String t) {
<p>
    int ss, tt;
<p>
    while (*s != '\0' && *s == *t) {
<p>
       s++;
<p>
       t++;
<p>
    }
<p>
    if (*s == '.') {
<p>
       ss = 1;
<p>
    } else {
<p>
       ss = (*s)<<1;
<p>
    }
<p>
    if (*t == '.') {
<p>
       tt = 1;
<p>
    } else {
<p>
       tt = (*t)<<1;
<p>
    }
<p>
    return (ss - tt);
<p>
 }
 </CODE>
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#Dictionary(net.sf.jlinkgrammar.ParseOptions, java.lang.String, java.lang.String, java.lang.String, java.lang.String)"><CODE>Dictionary(ParseOptions, String, String, String, String)</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/Sentence.html#Sentence(java.lang.String, net.sf.jlinkgrammar.Dictionary, net.sf.jlinkgrammar.ParseOptions)"><CODE>Sentence.Sentence(String input_string, Dictionary dict, ParseOptions opts)</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/Sentence.html#sentence_parse(net.sf.jlinkgrammar.ParseOptions)"><CODE>Sentence.sentence_parse(ParseOptions opts)</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Dictionary.html" title="class in net.sf.jlinkgrammar">Dictionary</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#affix_table">affix_table</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#already_got_it">already_got_it</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/ConnectorSet.html" title="class in net.sf.jlinkgrammar">ConnectorSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#andable_connector_set">andable_connector_set</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#andable_defined">andable_defined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#capitalized_word_defined">capitalized_word_defined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#CN_size">CN_size</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar">Postprocessor</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#constituent_pp">constituent_pp</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;java.lang.StringBuffer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#current_name">current_name</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#ed_word_defined">ed_word_defined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#exp_list">exp_list</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.io.Reader</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#fp">fp</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We link together all the Exp structs that are allocated in reading
 this dictionary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#hyphenated_word_defined">hyphenated_word_defined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#ing_word_defined">ing_word_defined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#is_special">is_special</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#left_wall_defined">left_wall_defined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#line_number">line_number</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#lookup_list">lookup_list</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#ly_word_defined">ly_word_defined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#max_cost">max_cost</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#name">name</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#num_entries">num_entries</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#number_word_defined">number_word_defined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#opts">opts</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#pl_capitalized_word_defined">pl_capitalized_word_defined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar">Postprocessor</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#postprocessor">postprocessor</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#rand_table_inited">rand_table_inited</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#right_wall_defined">right_wall_defined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#root">root</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#s_word_defined">s_word_defined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.StringBuffer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#token">token</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#unknown_word_defined">unknown_word_defined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/ConnectorSet.html" title="class in net.sf.jlinkgrammar">ConnectorSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#unlimited_connector_set">unlimited_connector_set</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#use_unknown_word">use_unknown_word</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/WordFile.html" title="class in net.sf.jlinkgrammar">WordFile</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#word_file_header">word_file_header</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#Dictionary(net.sf.jlinkgrammar.ParseOptions, java.lang.String, java.lang.String, java.lang.String, java.lang.String)">Dictionary</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
           java.lang.String&nbsp;dict_name,
           java.lang.String&nbsp;pp_name,
           java.lang.String&nbsp;cons_name,
           java.lang.String&nbsp;affix_name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the dictionary constructor method.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#abridged_lookup(java.lang.String)">abridged_lookup</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#advance()">advance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this reads the next token from the input into token</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#boolean_abridged_lookup(java.lang.String)">boolean_abridged_lookup</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#boolean_dictionary_lookup(java.lang.String)">boolean_dictionary_lookup</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#build_idiom_word_name(java.lang.String)">build_idiom_word_name</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates string space and returns a pointer to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#check_connector(java.lang.String)">check_connector</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makes sure the string s is a valid connector</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#connector()">connector</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the current token is a connector (or a dictionary word)
        make a node for it</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#contains_underbar(java.lang.String)">contains_underbar</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the string contains an underbar character.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#dict_compare(java.lang.String, java.lang.String)">dict_compare</A></B>(java.lang.String&nbsp;s,
             java.lang.String&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The data structure storing the dictionary is simply a binary tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#dict_display_word_info(java.lang.String)">dict_display_word_info</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#dict_error(java.lang.String)">dict_error</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#dict_match(java.lang.String, java.lang.String)">dict_match</A></B>(java.lang.String&nbsp;s,
           java.lang.String&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assuming that s is a pointer to a dictionary string, and that
      t is a pointer to a search string, this returns 0 if they
      match, >0 if s>t, and <0 if s<t.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#dictionary_lookup(java.lang.String)">dictionary_lookup</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a pointer to a lookup list of the words in the dictionary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;java.io.Reader</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#dictopen(net.sf.jlinkgrammar.ParseOptions, java.lang.String, java.lang.String)">dictopen</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
         java.lang.String&nbsp;dictname,
         java.lang.String&nbsp;filename)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function is used to open a dictionary file or a word file,
  or any associated data file (like a post process knowledge file).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#Exp_create()">Exp_create</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allocate a new Exp node and link it into the
           exp_list for freeing later</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#expression()">expression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#generate_id_connector()">generate_id_connector</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generate a new connector name
           obtained from the current_name
           allocate string space for it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#get_a_word(java.io.Reader)">get_a_word</A></B>(java.io.Reader&nbsp;fp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads in one word from the file, allocates space for it,
           and returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#get_character(boolean)">get_character</A></B>(boolean&nbsp;quote_mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This gets the next character from the input, eliminating comments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#increment_current_name()">increment_current_name</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#insert_dict(net.sf.jlinkgrammar.DictNode, net.sf.jlinkgrammar.DictNode)">insert_dict</A></B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;n,
            <A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;newNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Insert the new node into the dictionary below node n
 give error message if the new element's string is already there
 assumes that the "n" field of new is already set, and the left
 and right fields of it are null</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#insert_idiom(net.sf.jlinkgrammar.DictNode)">insert_idiom</A></B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;dn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Takes as input a pointer to a DictNode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#insert_list(net.sf.jlinkgrammar.DictNode, int)">insert_list</A></B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;p,
            int&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Insert the list into the dictionary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#is_ed_word(java.lang.String)">is_ed_word</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#is_equal(int)">is_equal</A></B>(int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returns true if this token is a special token and it is equal to c</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#is_idiom_number(java.lang.String)">is_idiom_number</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true if the string s is a sequence of digits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#is_idiom_string(java.lang.String)">is_idiom_string</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns false if it is not a correctly formed idiom string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#is_idiom_word(java.lang.String)">is_idiom_word</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#is_ing_word(java.lang.String)">is_ing_word</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#is_initials_word(java.lang.String)">is_initials_word</A></B>(java.lang.String&nbsp;word)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This might be a good place for entity extraction since all cap words
 often represent entities US, DOD etc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#is_ly_word(java.lang.String)">is_ly_word</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#is_number(java.lang.String)">is_number</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#is_s_word(java.lang.String)">is_s_word</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#ishyphenated(java.lang.String)">ishyphenated</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returns true iff it's an appropriately formed hyphenated word.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#make_idiom_DictNodes(java.lang.String)">make_idiom_DictNodes</A></B>(java.lang.String&nbsp;string)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tear the idiom string apart.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#make_optional_node(net.sf.jlinkgrammar.Exp)">make_optional_node</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This creates an OR node with two children, one the given node,
           and the other as zeroary node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#make_unary_node(net.sf.jlinkgrammar.Exp)">make_unary_node</A></B>(<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This creates a node with one child (namely e).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#make_zeroary_node()">make_zeroary_node</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This creates a node with zero children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#max_postfix_found(net.sf.jlinkgrammar.DictNode)">max_postfix_found</A></B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#numberfy(java.lang.String)">numberfy</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if the string contains a single ".", and ends in ".Ix" where
           x is a number, return x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#open_dictionary(java.lang.String)">open_dictionary</A></B>(java.lang.String&nbsp;dict_path_name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Opens the dictionary, sets the path and assigns the Dictionary object's
 filepointer to the dictionary specified in ParseOptions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar">Postprocessor</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#post_process_open(net.sf.jlinkgrammar.ParseOptions, java.lang.String, java.lang.String)">post_process_open</A></B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                  java.lang.String&nbsp;dictname,
                  java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read rules from path and initialize the appropriate fields in
     a postprocessor structure, a pointer to which is returned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#prune_lookup_list(java.lang.String)">prune_lookup_list</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#rabridged_lookup(net.sf.jlinkgrammar.DictNode, java.lang.String)">rabridged_lookup</A></B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;dn,
                 java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#rdictionary_lookup(net.sf.jlinkgrammar.DictNode, java.lang.String)">rdictionary_lookup</A></B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;dn,
                   java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#read_dictionary()">read_dictionary</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read the dictionary into memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#read_entry()">read_entry</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Starting with the current token parse one dictionary entry.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#read_word_file(net.sf.jlinkgrammar.DictNode, java.lang.String)">read_word_file</A></B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;dn,
               java.lang.String&nbsp;filename)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

   (1) opens the word file and adds it to the word file list
   (2) reads in the words
   (3) puts each word in a DictNode
   (4) links these together by their left pointers at the front of the list pointed to by dn
   (5) returns a pointer to the first of this list
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#restricted_expression(boolean, boolean)">restricted_expression</A></B>(boolean&nbsp;and_ok,
                      boolean&nbsp;or_ok)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#true_dict_match(java.lang.String, java.lang.String)">true_dict_match</A></B>(java.lang.String&nbsp;s,
                java.lang.String&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We need to prune out the lists thus generated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#warning(java.lang.String)">warning</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="root"><!-- --></A><H3>
root</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A> <B>root</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="name"><!-- --></A><H3>
name</H3>
<PRE>
public java.lang.String <B>name</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="use_unknown_word"><!-- --></A><H3>
use_unknown_word</H3>
<PRE>
public boolean <B>use_unknown_word</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="unknown_word_defined"><!-- --></A><H3>
unknown_word_defined</H3>
<PRE>
public boolean <B>unknown_word_defined</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="capitalized_word_defined"><!-- --></A><H3>
capitalized_word_defined</H3>
<PRE>
public boolean <B>capitalized_word_defined</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="pl_capitalized_word_defined"><!-- --></A><H3>
pl_capitalized_word_defined</H3>
<PRE>
public boolean <B>pl_capitalized_word_defined</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="hyphenated_word_defined"><!-- --></A><H3>
hyphenated_word_defined</H3>
<PRE>
public boolean <B>hyphenated_word_defined</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="number_word_defined"><!-- --></A><H3>
number_word_defined</H3>
<PRE>
public boolean <B>number_word_defined</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ing_word_defined"><!-- --></A><H3>
ing_word_defined</H3>
<PRE>
public boolean <B>ing_word_defined</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="s_word_defined"><!-- --></A><H3>
s_word_defined</H3>
<PRE>
public boolean <B>s_word_defined</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ed_word_defined"><!-- --></A><H3>
ed_word_defined</H3>
<PRE>
public boolean <B>ed_word_defined</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ly_word_defined"><!-- --></A><H3>
ly_word_defined</H3>
<PRE>
public boolean <B>ly_word_defined</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="left_wall_defined"><!-- --></A><H3>
left_wall_defined</H3>
<PRE>
public boolean <B>left_wall_defined</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="right_wall_defined"><!-- --></A><H3>
right_wall_defined</H3>
<PRE>
public boolean <B>right_wall_defined</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="postprocessor"><!-- --></A><H3>
postprocessor</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar">Postprocessor</A> <B>postprocessor</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="constituent_pp"><!-- --></A><H3>
constituent_pp</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar">Postprocessor</A> <B>constituent_pp</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="affix_table"><!-- --></A><H3>
affix_table</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/Dictionary.html" title="class in net.sf.jlinkgrammar">Dictionary</A> <B>affix_table</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="andable_defined"><!-- --></A><H3>
andable_defined</H3>
<PRE>
public boolean <B>andable_defined</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="andable_connector_set"><!-- --></A><H3>
andable_connector_set</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/ConnectorSet.html" title="class in net.sf.jlinkgrammar">ConnectorSet</A> <B>andable_connector_set</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="unlimited_connector_set"><!-- --></A><H3>
unlimited_connector_set</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/ConnectorSet.html" title="class in net.sf.jlinkgrammar">ConnectorSet</A> <B>unlimited_connector_set</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="max_cost"><!-- --></A><H3>
max_cost</H3>
<PRE>
public int <B>max_cost</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="num_entries"><!-- --></A><H3>
num_entries</H3>
<PRE>
public int <B>num_entries</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="opts"><!-- --></A><H3>
opts</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A> <B>opts</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="word_file_header"><!-- --></A><H3>
word_file_header</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/WordFile.html" title="class in net.sf.jlinkgrammar">WordFile</A> <B>word_file_header</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="exp_list"><!-- --></A><H3>
exp_list</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A> <B>exp_list</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fp"><!-- --></A><H3>
fp</H3>
<PRE>
public java.io.Reader <B>fp</B></PRE>
<DL>
<DD>We link together all the Exp structs that are allocated in reading
 this dictionary.  Used for freeing the dictionary
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="token"><!-- --></A><H3>
token</H3>
<PRE>
public java.lang.StringBuffer <B>token</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="is_special"><!-- --></A><H3>
is_special</H3>
<PRE>
public boolean <B>is_special</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="already_got_it"><!-- --></A><H3>
already_got_it</H3>
<PRE>
public int <B>already_got_it</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="line_number"><!-- --></A><H3>
line_number</H3>
<PRE>
public int <B>line_number</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="lookup_list"><!-- --></A><H3>
lookup_list</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A> <B>lookup_list</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="rand_table_inited"><!-- --></A><H3>
rand_table_inited</H3>
<PRE>
static boolean <B>rand_table_inited</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="current_name"><!-- --></A><H3>
current_name</H3>
<PRE>
static java.lang.StringBuffer <B>current_name</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="CN_size"><!-- --></A><H3>
CN_size</H3>
<PRE>
static final int <B>CN_size</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Dictionary(net.sf.jlinkgrammar.ParseOptions, java.lang.String, java.lang.String, java.lang.String, java.lang.String)"><!-- --></A><H3>
Dictionary</H3>
<PRE>
public <B>Dictionary</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                  java.lang.String&nbsp;dict_name,
                  java.lang.String&nbsp;pp_name,
                  java.lang.String&nbsp;cons_name,
                  java.lang.String&nbsp;affix_name)
           throws java.io.IOException</PRE>
<DL>
<DD>This is the dictionary constructor method.  It is the equivilent of the C function create_dictionary
 It calls a private constructor of the same name.
<P>
<DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="post_process_open(net.sf.jlinkgrammar.ParseOptions, java.lang.String, java.lang.String)"><!-- --></A><H3>
post_process_open</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar">Postprocessor</A> <B>post_process_open</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                                java.lang.String&nbsp;dictname,
                                java.lang.String&nbsp;path)
                          throws java.io.IOException</PRE>
<DL>
<DD>read rules from path and initialize the appropriate fields in
     a postprocessor structure, a pointer to which is returned.
     The only reason we need the dictname is to used it for the
     path, in case there is no DICTPATH set up.  If the dictname
     is null, and there is no DICTPATH, it just uses the filename
     as the full path.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opts</CODE> - the parse options. These are kept in many places, use care!<DD><CODE>dictname</CODE> - the dictionary to use. If fully qualified then sets the path for affix, etc.<DD><CODE>path</CODE> - Colon separated list of directories to search for ditionary, postprocessor etc.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE><DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/Postprocessor.html" title="class in net.sf.jlinkgrammar"><CODE>Postprocessor</CODE></A>, 
<A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#Dictionary(net.sf.jlinkgrammar.ParseOptions, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)"><CODE>Dictionary(ParseOptions, String, String, String, String, String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="open_dictionary(java.lang.String)"><!-- --></A><H3>
open_dictionary</H3>
<PRE>
boolean <B>open_dictionary</B>(java.lang.String&nbsp;dict_path_name)
                  throws java.io.IOException</PRE>
<DL>
<DD>Opens the dictionary, sets the path and assigns the Dictionary object's
 filepointer to the dictionary specified in ParseOptions.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dict_path_name</CODE> - the fully qualified? path to the ditionary?
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE><DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#dictopen(net.sf.jlinkgrammar.ParseOptions, java.lang.String, java.lang.String)"><CODE>dictopen(ParseOptions, String, String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="read_dictionary()"><!-- --></A><H3>
read_dictionary</H3>
<PRE>
public void <B>read_dictionary</B>()
                     throws java.io.IOException</PRE>
<DL>
<DD>Read the dictionary into memory. This musr be preceded by opening the dictionary
 and seting the file pointer using open_dictionary.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE><DT><B>See Also:</B><DD><A HREF="../../../net/sf/jlinkgrammar/Dictionary.html#open_dictionary(java.lang.String)"><CODE>open_dictionary(String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="dictionary_lookup(java.lang.String)"><!-- --></A><H3>
dictionary_lookup</H3>
<PRE>
public <A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A> <B>dictionary_lookup</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD>Returns a pointer to a lookup list of the words in the dictionary.
      This list is made up of DictNodes, linked by their right pointers.
      The node, file and string fields are copied from the dictionary.

      Freeing this list elsewhere is unnecessary, as long as the rest of
      the program merely examines the list (doesn't change it)
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="prune_lookup_list(java.lang.String)"><!-- --></A><H3>
prune_lookup_list</H3>
<PRE>
void <B>prune_lookup_list</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="rdictionary_lookup(net.sf.jlinkgrammar.DictNode, java.lang.String)"><!-- --></A><H3>
rdictionary_lookup</H3>
<PRE>
void <B>rdictionary_lookup</B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;dn,
                        java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dn</CODE> - <DD><CODE>s</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="boolean_dictionary_lookup(java.lang.String)"><!-- --></A><H3>
boolean_dictionary_lookup</H3>
<PRE>
boolean <B>boolean_dictionary_lookup</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - 
<DT><B>Returns:</B><DD>true if string is in this dictionary</DL>
</DD>
</DL>
<HR>

<A NAME="rabridged_lookup(net.sf.jlinkgrammar.DictNode, java.lang.String)"><!-- --></A><H3>
rabridged_lookup</H3>
<PRE>
void <B>rabridged_lookup</B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;dn,
                      java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dn</CODE> - <DD><CODE>s</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="abridged_lookup(java.lang.String)"><!-- --></A><H3>
abridged_lookup</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A> <B>abridged_lookup</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - 
<DT><B>Returns:</B><DD>a linked list of dictionary nodes containing the string</DL>
</DD>
</DL>
<HR>

<A NAME="boolean_abridged_lookup(java.lang.String)"><!-- --></A><H3>
boolean_abridged_lookup</H3>
<PRE>
boolean <B>boolean_abridged_lookup</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>

<DT><B>Returns:</B><DD>true if in the dictionary, false otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="dict_match(java.lang.String, java.lang.String)"><!-- --></A><H3>
dict_match</H3>
<PRE>
int <B>dict_match</B>(java.lang.String&nbsp;s,
               java.lang.String&nbsp;t)</PRE>
<DL>
<DD>assuming that s is a pointer to a dictionary string, and that
      t is a pointer to a search string, this returns 0 if they
      match, >0 if s>t, and <0 if s<t.
 <p>
      The matching is done as follows.  Walk down the strings until
      you come to the end of one of them, or until you find unequal
      characters.  A "*" matches anything.  Otherwise, replace "."
      by "\0", and take the difference.  This behavior matches that
      of the function dict_compare().
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="true_dict_match(java.lang.String, java.lang.String)"><!-- --></A><H3>
true_dict_match</H3>
<PRE>
boolean <B>true_dict_match</B>(java.lang.String&nbsp;s,
                        java.lang.String&nbsp;t)</PRE>
<DL>
<DD>We need to prune out the lists thus generated.
 A sub string will only be considered a subscript if it
 followes the last "." in the word, and it does not begin
 with a digit.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="dict_display_word_info(java.lang.String)"><!-- --></A><H3>
dict_display_word_info</H3>
<PRE>
void <B>dict_display_word_info</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="is_idiom_string(java.lang.String)"><!-- --></A><H3>
is_idiom_string</H3>
<PRE>
static boolean <B>is_idiom_string</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD>Returns false if it is not a correctly formed idiom string.
<p>
      correct such string:
 <p>
      () contains no "."
 <p>
      () non-empty strings separated by _
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - word to lookup
<DT><B>Returns:</B><DD>false if it is not a correctly formed idiom string.</DL>
</DD>
</DL>
<HR>

<A NAME="is_idiom_word(java.lang.String)"><!-- --></A><H3>
is_idiom_word</H3>
<PRE>
static boolean <B>is_idiom_word</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - 
<DT><B>Returns:</B><DD>true if the word is an idiom</DL>
</DD>
</DL>
<HR>

<A NAME="is_initials_word(java.lang.String)"><!-- --></A><H3>
is_initials_word</H3>
<PRE>
static boolean <B>is_initials_word</B>(java.lang.String&nbsp;word)</PRE>
<DL>
<DD>This might be a good place for entity extraction since all cap words
 often represent entities US, DOD etc. Perhaps we should add a dictionary?
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>word</CODE> - 
<DT><B>Returns:</B><DD>true if the word is all capitol letters - probably an accronym</DL>
</DD>
</DL>
<HR>

<A NAME="is_number(java.lang.String)"><!-- --></A><H3>
is_number</H3>
<PRE>
static boolean <B>is_number</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - 
<DT><B>Returns:</B><DD>true if it is a number</DL>
</DD>
</DL>
<HR>

<A NAME="ishyphenated(java.lang.String)"><!-- --></A><H3>
ishyphenated</H3>
<PRE>
static boolean <B>ishyphenated</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD>returns true iff it's an appropriately formed hyphenated word.
           This means all letters, numbers, or hyphens, not beginning and
           ending with a hyphen.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - 
<DT><B>Returns:</B><DD>true if hyphenated</DL>
</DD>
</DL>
<HR>

<A NAME="is_ing_word(java.lang.String)"><!-- --></A><H3>
is_ing_word</H3>
<PRE>
static boolean <B>is_ing_word</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - 
<DT><B>Returns:</B><DD>true if word ends in ing</DL>
</DD>
</DL>
<HR>

<A NAME="is_s_word(java.lang.String)"><!-- --></A><H3>
is_s_word</H3>
<PRE>
static boolean <B>is_s_word</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - 
<DT><B>Returns:</B><DD>if word ends in s</DL>
</DD>
</DL>
<HR>

<A NAME="is_ed_word(java.lang.String)"><!-- --></A><H3>
is_ed_word</H3>
<PRE>
static boolean <B>is_ed_word</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - 
<DT><B>Returns:</B><DD>true if word ends in ed</DL>
</DD>
</DL>
<HR>

<A NAME="is_ly_word(java.lang.String)"><!-- --></A><H3>
is_ly_word</H3>
<PRE>
static boolean <B>is_ly_word</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - 
<DT><B>Returns:</B><DD>true if word ends in ly</DL>
</DD>
</DL>
<HR>

<A NAME="numberfy(java.lang.String)"><!-- --></A><H3>
numberfy</H3>
<PRE>
static int <B>numberfy</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD>if the string contains a single ".", and ends in ".Ix" where
           x is a number, return x.  Return -1 if not of this form.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="is_idiom_number(java.lang.String)"><!-- --></A><H3>
is_idiom_number</H3>
<PRE>
static boolean <B>is_idiom_number</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD>return true if the string s is a sequence of digits.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="contains_underbar(java.lang.String)"><!-- --></A><H3>
contains_underbar</H3>
<PRE>
static boolean <B>contains_underbar</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD>Returns true if the string contains an underbar character.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="dict_error(java.lang.String)"><!-- --></A><H3>
dict_error</H3>
<PRE>
void <B>dict_error</B>(java.lang.String&nbsp;s)
          throws java.io.IOException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="warning(java.lang.String)"><!-- --></A><H3>
warning</H3>
<PRE>
void <B>warning</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="Exp_create()"><!-- --></A><H3>
Exp_create</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A> <B>Exp_create</B>()</PRE>
<DL>
<DD>allocate a new Exp node and link it into the
           exp_list for freeing later
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="get_character(boolean)"><!-- --></A><H3>
get_character</H3>
<PRE>
int <B>get_character</B>(boolean&nbsp;quote_mode)
            throws java.io.IOException</PRE>
<DL>
<DD>This gets the next character from the input, eliminating comments.
           If we're in quote mode, it does not consider the % character for
           comments
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="advance()"><!-- --></A><H3>
advance</H3>
<PRE>
boolean <B>advance</B>()
          throws java.io.IOException</PRE>
<DL>
<DD>this reads the next token from the input into token
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="is_equal(int)"><!-- --></A><H3>
is_equal</H3>
<PRE>
boolean <B>is_equal</B>(int&nbsp;c)</PRE>
<DL>
<DD>returns true if this token is a special token and it is equal to c
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="check_connector(java.lang.String)"><!-- --></A><H3>
check_connector</H3>
<PRE>
boolean <B>check_connector</B>(java.lang.String&nbsp;s)
                  throws java.io.IOException</PRE>
<DL>
<DD>makes sure the string s is a valid connector
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="connector()"><!-- --></A><H3>
connector</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A> <B>connector</B>()
        throws java.io.IOException</PRE>
<DL>
<DD>the current token is a connector (or a dictionary word)
        make a node for it
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="make_unary_node(net.sf.jlinkgrammar.Exp)"><!-- --></A><H3>
make_unary_node</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A> <B>make_unary_node</B>(<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A>&nbsp;e)</PRE>
<DL>
<DD>This creates a node with one child (namely e).  Initializes
 the cost to zero
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="make_zeroary_node()"><!-- --></A><H3>
make_zeroary_node</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A> <B>make_zeroary_node</B>()</PRE>
<DL>
<DD>This creates a node with zero children.  Initializes

      the cost to zero
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="make_optional_node(net.sf.jlinkgrammar.Exp)"><!-- --></A><H3>
make_optional_node</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A> <B>make_optional_node</B>(<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A>&nbsp;e)</PRE>
<DL>
<DD>This creates an OR node with two children, one the given node,
           and the other as zeroary node.  This has the effect of creating
           what used to be called an optional node.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="expression()"><!-- --></A><H3>
expression</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A> <B>expression</B>()
         throws java.io.IOException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="restricted_expression(boolean, boolean)"><!-- --></A><H3>
restricted_expression</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/Exp.html" title="class in net.sf.jlinkgrammar">Exp</A> <B>restricted_expression</B>(boolean&nbsp;and_ok,
                          boolean&nbsp;or_ok)
                    throws java.io.IOException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="dict_compare(java.lang.String, java.lang.String)"><!-- --></A><H3>
dict_compare</H3>
<PRE>
int <B>dict_compare</B>(java.lang.String&nbsp;s,
                 java.lang.String&nbsp;t)</PRE>
<DL>
<DD>The data structure storing the dictionary is simply a binary tree.
 There is one catch however.  The ordering of the words is not
 exactly the order given by strcmp.  It was necessary to
 modify the order to make it so that "make" < "make.n" < "make-up"
 The problem is that if some other string could  lie between '\0'
 and '.' (such as '-' which strcmp would give) then it makes it much
 harder to return all the strings that match a given word.
 For example, if "make-up" was inserted, then "make" was inserted
 the a search was done for "make.n", the obvious algorithm would
 not find the match.
 <p>
 verbose version
<PRE>
 int dict_compare(String s, String t) {
    int ss, tt;
    while (*s != '\0' && *s == *t) {
    s++;
    t++;
    }
    if (*s == '.') {
    ss = 1;
    } else {
    ss = (*s)<<1;
    }
    if (*t == '.') {
    tt = 1;
    } else {
    tt = (*t)<<1;
    }
    return (ss - tt);
 }
 </PRE>
        terse version
        <PRE>
        int dict_compare(String s, String t) {
            int i = 0;
            while (i < s.length() && i < t.length() && s.charAt(i) == t.charAt(i)) {
                i++;
            }
        return (i >= s.length() ? 0 : (s.charAt(i) == '.' ? 1 : (s.charAt(i) << 1)))
                - (i >= t.length() ? 0 : (t.charAt(i) == '.' ? 1 : (t.charAt(i) << 1)));
        }
        </PRE>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="insert_dict(net.sf.jlinkgrammar.DictNode, net.sf.jlinkgrammar.DictNode)"><!-- --></A><H3>
insert_dict</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A> <B>insert_dict</B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;n,
                     <A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;newNode)
               throws java.io.IOException</PRE>
<DL>
<DD>Insert the new node into the dictionary below node n
 give error message if the new element's string is already there
 assumes that the "n" field of new is already set, and the left
 and right fields of it are null
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="insert_list(net.sf.jlinkgrammar.DictNode, int)"><!-- --></A><H3>
insert_list</H3>
<PRE>
void <B>insert_list</B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;p,
                 int&nbsp;l)
           throws java.io.IOException</PRE>
<DL>
<DD>Insert the list into the dictionary.
 It does the middle one first, then the left half, then the right.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p</CODE> - points to a list of dict_nodes connected by their left pointers<DD><CODE>l</CODE> - is the length of this list (the last ptr may not be null)
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="read_entry()"><!-- --></A><H3>
read_entry</H3>
<PRE>
boolean <B>read_entry</B>()
             throws java.io.IOException</PRE>
<DL>
<DD>Starting with the current token parse one dictionary entry.
 Add these words to the dictionary
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="insert_idiom(net.sf.jlinkgrammar.DictNode)"><!-- --></A><H3>
insert_idiom</H3>
<PRE>
void <B>insert_idiom</B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;dn)
            throws java.io.IOException</PRE>
<DL>
<DD>Takes as input a pointer to a DictNode.
           The string of this DictNode is an idiom string.
           This string is torn apart, and its components are inserted into the
           dictionary as special idiom words (ending in .I*, where * is a number).
           The expression of this DictNode (its node field) has already been
           read and constructed.  This will be used to construct the special idiom
           expressions.
           The given dict node is freed.  The string is also freed.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="read_word_file(net.sf.jlinkgrammar.DictNode, java.lang.String)"><!-- --></A><H3>
read_word_file</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A> <B>read_word_file</B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;dn,
                        java.lang.String&nbsp;filename)
                  throws java.io.IOException</PRE>
<DL>
<DD><ul>

 <li>  (1) opens the word file and adds it to the word file list
 <li>  (2) reads in the words
 <li>  (3) puts each word in a DictNode
 <li>  (4) links these together by their left pointers at the front of the list pointed to by dn
 <li>  (5) returns a pointer to the first of this list
 <ul>
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="get_a_word(java.io.Reader)"><!-- --></A><H3>
get_a_word</H3>
<PRE>
java.lang.String <B>get_a_word</B>(java.io.Reader&nbsp;fp)
                      throws java.io.IOException</PRE>
<DL>
<DD>Reads in one word from the file, allocates space for it,
           and returns it.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="dictopen(net.sf.jlinkgrammar.ParseOptions, java.lang.String, java.lang.String)"><!-- --></A><H3>
dictopen</H3>
<PRE>
static java.io.Reader <B>dictopen</B>(<A HREF="../../../net/sf/jlinkgrammar/ParseOptions.html" title="class in net.sf.jlinkgrammar">ParseOptions</A>&nbsp;opts,
                               java.lang.String&nbsp;dictname,
                               java.lang.String&nbsp;filename)
                        throws java.io.IOException</PRE>
<DL>
<DD>This function is used to open a dictionary file or a word file,
  or any associated data file (like a post process knowledge file).
 <p>
  It works as follows.  If the file name begins with a "/", then
  it's assumed to be an absolute file name and it tries to open
  that exact file.
 <p>
  If the filename does not begin with a "/", then it uses the
  dictpath mechanism to find the right file to open.  This looks
  for the file in a sequence of directories until it finds it.  The
  sequence of directories is specified in a dictpath string, in
  which each directory is followed by a ":".
  <p>
   The dictpath that it uses is constructed as follows.  If the
   dictname is non-null, and is an absolute path name (beginning
   with a "/", then the part after the last "/" is removed and this
   is the first directory on the dictpath.  After this comes the
   DICTPATH environment variable, followed by the DEFAULTPATH
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="generate_id_connector()"><!-- --></A><H3>
generate_id_connector</H3>
<PRE>
java.lang.String <B>generate_id_connector</B>()</PRE>
<DL>
<DD>generate a new connector name
           obtained from the current_name
           allocate string space for it.
           return a pointer to it.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="build_idiom_word_name(java.lang.String)"><!-- --></A><H3>
build_idiom_word_name</H3>
<PRE>
java.lang.String <B>build_idiom_word_name</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD>Allocates string space and returns a pointer to it.
     In this string is placed the idiomized name of the given string s.
     This is the same as s, but with a postfix of ".Ix", where x is an
     appropriate number.  x is the minimum number that distinguishes
     this word from others in the dictionary.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="max_postfix_found(net.sf.jlinkgrammar.DictNode)"><!-- --></A><H3>
max_postfix_found</H3>
<PRE>
int <B>max_postfix_found</B>(<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A>&nbsp;d)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="make_idiom_DictNodes(java.lang.String)"><!-- --></A><H3>
make_idiom_DictNodes</H3>
<PRE>
<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar">DictNode</A> <B>make_idiom_DictNodes</B>(java.lang.String&nbsp;string)</PRE>
<DL>
<DD>Tear the idiom string apart.
           Destroys the string s, but does not free it.
           Put the parts into a list of DictNodes (connected by their right pointers)
           Sets the string fields of these DictNodes pointing to the
           fragments of the string s.  Later these will be replaced by
           correct names (with .Ix suffixes).
           The list is reversed from the way they occur in the string.
           A pointer to this list is returned.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="increment_current_name()"><!-- --></A><H3>
increment_current_name</H3>
<PRE>
void <B>increment_current_name</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/sf/jlinkgrammar/Constituent.html" title="class in net.sf.jlinkgrammar"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../net/sf/jlinkgrammar/DictNode.html" title="class in net.sf.jlinkgrammar"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/sf/jlinkgrammar/Dictionary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Dictionary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
